"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// tslint:disable:no-console
const child_process_1 = __importDefault(require("child_process"));
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
require("should");
const lib_1 = require("../lib");
const with_openssl_1 = require("../lib/toolbox/with_openssl");
const helpers_1 = require("./helpers");
const n = lib_1.makePath;
function create_demo_certificates(cwd) {
    return __awaiter(this, void 0, void 0, function* () {
        yield call_crypto_create_CA("demo --dev", cwd);
    });
}
function call_crypto_create_CA(cmdArguments, cwd) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!fs_1.default.existsSync(cwd)) {
            throw new Error(" current folder shall exist " + cwd);
        }
        const rootFolder = process.cwd();
        const cmd = "node";
        const args1 = n(path_1.default.join(rootFolder, "./bin/crypto_create_CA.cjs")) + " " + cmdArguments;
        const args = args1.replace("  ", " ").split(" ");
        const options = {
            cwd,
        };
        yield new Promise((resolve) => {
            const child = child_process_1.default.spawn(cmd, args, options);
            if (process.env.DEBUG) {
                console.log(" cwd = ", cwd);
                console.log(" cmd = ", cmd);
                console.log(" args = ", args);
                console.log("", cmd, args.join(" "));
            }
            child.stdout.on("data", () => {
                if (process.env.DEBUG) {
                    process.stdout.write(".");
                }
            });
            const doLog = false;
            if (doLog) {
                const logFile = path_1.default.join(__dirname, "../tmp/log.txt");
                const logStream = fs_1.default.createWriteStream(logFile);
                child.stdout.pipe(logStream);
                child.stderr.pipe(logStream);
            }
            child.stderr.pipe(process.stderr);
            child.on("exit", (code) => {
                if (process.env.DEBUG) {
                    console.log("done ... (" + code + ")");
                }
                resolve();
            });
        });
    });
}
describe("testing test_crypto_create_CA", function () {
    this.timeout(2300000);
    const testData = (0, helpers_1.beforeTest)(this);
    it("should create a PKI with demo certificates", () => __awaiter(this, void 0, void 0, function* () {
        console.log("    .... be patient ... demo certificates are being created ...");
        const cwd = path_1.default.join(__dirname, "../tmp");
        const certificate_file = path_1.default.join(cwd, "certificates/discoveryServer_cert_2048.pem");
        fs_1.default.existsSync(certificate_file).should.eql(false);
        // console.log(" certificate_file = ", certificate_file);
        const date1 = new Date();
        yield create_demo_certificates(cwd);
        fs_1.default.existsSync(certificate_file).should.eql(true, "certificate " + certificate_file + " must exist");
        // running a second time should be faster
        const date2 = new Date();
        yield create_demo_certificates(cwd);
        const date3 = new Date();
        const initialTimeToConstructDemoCertificate = date2.getTime() - date1.getTime();
        console.log(" t1 = ", initialTimeToConstructDemoCertificate);
        const timeToConstructDemoCertificateSecondTime = date3.getTime() - date2.getTime();
        console.log(" t2 = ", timeToConstructDemoCertificateSecondTime);
        (initialTimeToConstructDemoCertificate / 1.2).should.be.greaterThan(timeToConstructDemoCertificateSecondTime, "it should take less time the second pass");
    }));
    describe("self-signed certificates", () => {
        it("should create a self-signed certificate - variation 1", () => __awaiter(this, void 0, void 0, function* () {
            const cwd = path_1.default.join(__dirname, "../tmp/zzz1");
            fs_1.default.mkdirSync(cwd);
            const csrFile = path_1.default.join(cwd, "my_certificate.pem.csr");
            const certificateFile = path_1.default.join(cwd, "my_certificate.pem");
            yield call_crypto_create_CA("certificate --selfSigned --silent=false", cwd);
            fs_1.default.existsSync(certificateFile).should.eql(true, "file " + certificateFile + " should exist");
            fs_1.default.existsSync(csrFile).should.eql(false, "useless signing request shall be automatically removed (" + csrFile + ")");
        }));
        it("should create a self-signed certificate - variation 2 - --output ", () => __awaiter(this, void 0, void 0, function* () {
            const cwd = path_1.default.join(__dirname, "../tmp/zzz2");
            fs_1.default.mkdirSync(cwd);
            const expectedCertificate = path_1.default.join(cwd, "mycert.pem");
            yield call_crypto_create_CA("certificate --selfSigned -o mycert.pem", cwd);
            fs_1.default.existsSync(expectedCertificate).should.eql(true);
            fs_1.default.existsSync(path_1.default.join(cwd, "mycert.pem.csr")).should.eql(false, "useless signing request shall be automatically removed");
            const data = yield (0, with_openssl_1.dumpCertificate)(expectedCertificate);
            (0, helpers_1.grep)(data, /Public.Key/).should.match(/Public.Key: \(2048 bit\)/);
            // XX grep(data,/URI/).should.match(/URI:MY:APPLICATION:URI/);
            // XX grep(data,/DNS/).should.match(/DNS:localhost/);
            // XX grep(data,/DNS/).should.match(/DNS:my.domain.com/);
        }));
        it("should create a self-signed certificate - variation 3 - --applicationUrI", () => __awaiter(this, void 0, void 0, function* () {
            const cwd = path_1.default.join(__dirname, "../tmp/zzz3");
            fs_1.default.mkdirSync(cwd);
            const expectedCertificate = path_1.default.join(cwd, "mycert.pem");
            yield call_crypto_create_CA("certificate -a urn:MYSERVER:APPLICATION --selfSigned -o mycert.pem", cwd);
            fs_1.default.existsSync(expectedCertificate).should.eql(true);
            fs_1.default.existsSync(path_1.default.join(cwd, "mycert.pem.csr")).should.eql(false, "useless signing request shall be automatically removed");
            const data = yield (0, with_openssl_1.dumpCertificate)(expectedCertificate);
            (0, helpers_1.grep)(data, /Public.Key/).should.match(/Public.Key: \(2048 bit\)/);
            (0, helpers_1.grep)(data, /URI/).should.match(/urn:MYSERVER:APPLICATION/);
            // XX grep(data,/DNS/).should.match(/DNS:localhost/);
            // XX grep(data,/DNS/).should.match(/DNS:my.domain.com/);
        }));
        function daysBetween(date1, date2) {
            // Get 1 day in milliseconds
            const oneDay = 1000 * 60 * 60 * 24;
            // Convert both dates to milliseconds
            const date1Ms = date1.getTime();
            const date2Ms = date2.getTime();
            // Calculate the difference in milliseconds
            const differenceMs = date2Ms - date1Ms;
            // Convert back to days and return
            return Math.round(differenceMs / oneDay);
        }
        it("should create a self-signed certificate - variation 4 - --validity", () => __awaiter(this, void 0, void 0, function* () {
            const cwd = path_1.default.join(__dirname, "../tmp/zzz4");
            fs_1.default.mkdirSync(cwd);
            const expectedCertificate = path_1.default.join(cwd, "mycert.pem");
            const validity = 10; // days
            yield call_crypto_create_CA("certificate -v " + validity + " --selfSigned -o mycert.pem", cwd);
            fs_1.default.existsSync(expectedCertificate).should.eql(true);
            fs_1.default.existsSync(path_1.default.join(cwd, "mycert.pem.csr")).should.eql(false, "useless signing request shall be automatically removed");
            const data = yield (0, with_openssl_1.dumpCertificate)(expectedCertificate);
            (0, helpers_1.grep)(data, /Public.Key/).should.match(/Public.Key: \(2048 bit\)/);
            const _startDate = (0, helpers_1.grep)(data, /Not Before/)
                .match(/Not Before:(.*)/)[1]
                .trim();
            const _endDate = (0, helpers_1.grep)(data, /Not After/)
                .match(/Not After :(.*)/)[1]
                .trim();
            const startDate = new Date(Date.parse(_startDate));
            const endDate = new Date(Date.parse(_endDate));
            const validityCheck = daysBetween(startDate, endDate);
            validityCheck.should.eql(validity);
        }));
        it("should create a self-signed certificate - variation 5 - --dns", () => __awaiter(this, void 0, void 0, function* () {
            const cwd = path_1.default.join(__dirname, "../tmp/zzz5");
            fs_1.default.mkdirSync(cwd);
            const expectedCertificate = path_1.default.join(cwd, "mycert.pem");
            const validity = 10; // days
            yield call_crypto_create_CA("certificate -v " + validity + " --dns HOST1,HOST2 --selfSigned -o mycert.pem", cwd);
            fs_1.default.existsSync(expectedCertificate).should.eql(true, "should find certificate " + expectedCertificate);
            const data = yield (0, with_openssl_1.dumpCertificate)(expectedCertificate);
            (0, helpers_1.grep)(data, /Public.Key/).should.match(/Public.Key: \(2048 bit\)/);
            (0, helpers_1.grep)(data, /DNS/).should.match(/DNS:HOST1/);
            (0, helpers_1.grep)(data, /DNS/).should.match(/DNS:HOST2/);
        }));
        it("should create a self-signed certificate - variation 6 - --ip", () => __awaiter(this, void 0, void 0, function* () {
            const cwd = path_1.default.join(__dirname, "../tmp/zzz6");
            fs_1.default.mkdirSync(cwd);
            const expectedCertificate = path_1.default.join(cwd, "mycert.pem");
            const validity = 10; // days
            yield call_crypto_create_CA("certificate -v " + validity + " --ip 128.12.13.13,128.128.128.128 --selfSigned -o mycert.pem", cwd);
            fs_1.default.existsSync(expectedCertificate).should.eql(true);
            const data = yield (0, with_openssl_1.dumpCertificate)(expectedCertificate);
            if (false) {
                console.log(data);
            }
            (0, helpers_1.grep)(data, /Public.Key/).should.match(/Public.Key: \(2048 bit\)/);
            (0, helpers_1.grep)(data, /IP/).should.match(/IP Address:128.12.13.13/);
            (0, helpers_1.grep)(data, /IP/).should.match(/IP Address:128.128.128.128/);
        }));
        it("should create a self-signed certificate - variation 7 - --subject", () => __awaiter(this, void 0, void 0, function* () {
            const cwd = path_1.default.join(__dirname, "../tmp/zzz7");
            fs_1.default.mkdirSync(cwd);
            const expectedCertificate = path_1.default.join(cwd, "mycert.pem");
            const validity = 10; // days
            yield call_crypto_create_CA("certificate -v " +
                validity +
                " --subject='C=FR/ST=Centre/L=Orleans/O=SomeOrganization/CN=Hello' --selfSigned -o mycert.pem", cwd);
            fs_1.default.existsSync(expectedCertificate).should.eql(true);
            const data = yield (0, with_openssl_1.dumpCertificate)(expectedCertificate);
            if (false) {
                console.log(data);
            }
            (0, helpers_1.grep)(data, /C\s?=\s?FR, ST\s?=\s?Centre, L\s?=\s?Orleans, O\s?=\s?SomeOrganization, CN\s?=\s?Hello/).should.match(/SomeOrganization/, "should have SomeOrganization " + data);
        }));
    });
    describe("createCA & PKI", () => {
        it("@1 should create a CA and a PKI with 4096 bits keys", () => __awaiter(this, void 0, void 0, function* () {
            const cwd = path_1.default.join(__dirname, "../tmp/tmp4096");
            fs_1.default.mkdirSync(cwd);
            yield call_crypto_create_CA("createCA --keySize 4096", cwd);
            const caPrivateKey = path_1.default.join(__dirname, "../tmp/tmp4096/certificates/CA/private/cakey.pem");
            fs_1.default.existsSync(caPrivateKey).should.eql(true);
            yield call_crypto_create_CA("createPKI --keySize 4096", cwd);
            const pkiPrivateKey = path_1.default.join(__dirname, "../tmp/tmp4096/certificates/PKI/own/private/private_key.pem");
            fs_1.default.existsSync(pkiPrivateKey).should.eql(true);
        }));
        it("@2 should create a CA with a customer subject", () => __awaiter(this, void 0, void 0, function* () {
            const cwd = path_1.default.join(__dirname, "../tmp/tmpCAcustomSubject");
            fs_1.default.mkdirSync(cwd);
            yield call_crypto_create_CA("createCA --keySize 4096 --subject CN=Toto/C=FR/O=MyOrganization", cwd);
            const caPrivateKey = path_1.default.join(__dirname, "../tmp/tmpCAcustomSubject/certificates/CA/private/cakey.pem");
            fs_1.default.existsSync(caPrivateKey).should.eql(true, "caPrivateKey shall exist : " + caPrivateKey);
        }));
    });
    describe("certificates signed by Local CA Authority", () => {
        it("should create a signed certificate - variation 1", () => __awaiter(this, void 0, void 0, function* () {
            const cwd = path_1.default.join(__dirname, "../tmp/yyy1");
            fs_1.default.mkdirSync(cwd);
            yield call_crypto_create_CA("certificate", cwd);
        }));
        xit("ZZ0 should create a signed certificate - variation 2", () => __awaiter(this, void 0, void 0, function* () {
            const cwd = path_1.default.join(__dirname, "../tmp/yyy2");
            fs_1.default.mkdirSync(cwd);
            const expectedCertificate = path_1.default.join(cwd, "mycert.pem");
            yield call_crypto_create_CA("certificate -o " + "mycert.pem", cwd);
            fs_1.default.existsSync(expectedCertificate).should.eql(true);
        }));
        it("should create a signed certificate - using subject - variation 7 - --subject", () => __awaiter(this, void 0, void 0, function* () {
            const cwd = path_1.default.join(__dirname, "../tmp/yyy7");
            fs_1.default.mkdirSync(cwd);
            const expectedCertificate = path_1.default.join(cwd, "mycert.pem");
            const validity = 10; // days
            yield call_crypto_create_CA("certificate -v " + validity + " --subject=C=FR/ST=Centre/L=Orleans/O=SomeOrganization/CN=Hello -o mycert.pem", cwd);
            fs_1.default.existsSync(expectedCertificate).should.eql(true);
            const data = yield (0, with_openssl_1.dumpCertificate)(expectedCertificate);
            if (false) {
                console.log(data);
            }
            (0, helpers_1.grep)(data, /C\s?=\s?FR, ST\s?=\s?Centre, L\s?=\s?Orleans, O\s?=\s?SomeOrganization, CN\s?=\s?Hello/).should.match(/SomeOrganization/);
        }));
    });
});
//# sourceMappingURL=test_crypto_create_CA.js.map