"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const sinon_1 = __importDefault(require("sinon"));
require("should");
const lib_1 = require("../lib");
const helpers_1 = require("./helpers");
const node_opcua_crypto_1 = require("node-opcua-crypto");
describe("Check Validate Certificate", function () {
    const testData = (0, helpers_1.beforeTest)(this);
    let clock;
    before(() => {
        clock = sinon_1.default.useFakeTimers({
            shouldAdvanceTime: true,
            now: new Date(2020, 1, 12).getTime(),
        });
    });
    after(() => {
        clock.restore();
    });
    it("should verifyCertificateAsync", () => __awaiter(this, void 0, void 0, function* () {
        const options = {
            location: path_1.default.join(testData.tmpFolder, "PKI"),
        };
        const certificateManager = new lib_1.CertificateManager(options);
        yield certificateManager.initialize();
        const caCertificateFilename = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1I.der");
        const crlFilename = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/crl/ctt_ca1I.crl");
        const cert1Filename = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1I_appT.der");
        const cert2Filename = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1I_appTR.der");
        // installing the CA certificate
        const caCert = (0, node_opcua_crypto_1.readCertificate)(caCertificateFilename);
        let caCertStatus = yield certificateManager.verifyCertificate(caCert);
        caCertStatus.should.eql("BadCertificateUntrusted");
        // installing the 1st cer
        const cert1 = fs_1.default.readFileSync(cert1Filename);
        const cert2 = fs_1.default.readFileSync(cert2Filename);
        yield certificateManager.trustCertificate(cert1);
        yield certificateManager.trustCertificate(cert2);
        {
            const cert1Status = yield certificateManager.verifyCertificate(cert1);
            // should be -BadCertificateChainIncomplete because the issuer cert is not in the issuer list
            cert1Status.should.eql("BadCertificateChainIncomplete");
        }
        // installing the 2nd cert
        {
            const cert2Status = yield certificateManager.verifyCertificate(cert2);
            // should be -BadCertificateChainIncomplete because the issuer cert is not in the issuer list
            cert2Status.should.eql("BadCertificateChainIncomplete");
        }
        // now move the caCert to the issue list
        const status = yield certificateManager.addIssuer(caCert, true);
        status.should.eql("Good");
        caCertStatus = yield certificateManager.verifyCertificate(caCert);
        caCertStatus.should.eql("BadCertificateUntrusted");
        {
            const cert1Status = yield certificateManager.verifyCertificate(cert1);
            cert1Status.should.eql("BadCertificateRevocationUnknown");
            const cert1Status1 = yield certificateManager.verifyCertificate(cert1, {});
            cert1Status1.should.eql("BadCertificateRevocationUnknown");
            const cert1Status2 = yield certificateManager.verifyCertificate(cert1, { ignoreMissingRevocationList: true });
            cert1Status2.should.eql("Good");
        }
        //
        {
            const certEStatus = yield certificateManager.verifyCertificate(cert2);
            certEStatus.should.eql("BadCertificateRevocationUnknown");
        }
        // now move the crl to the crl list
        const crl = fs_1.default.readFileSync(crlFilename);
        yield certificateManager.addRevocationList(crl);
        {
            const cert1Status = yield certificateManager.verifyCertificate(cert1);
            cert1Status.should.eql("Good");
        }
        {
            const cert2Status = yield certificateManager.verifyCertificate(cert2);
            cert2Status.should.eql("BadCertificateRevoked");
        }
    }));
});
//# sourceMappingURL=test_advanced_certificate_validation.js.map