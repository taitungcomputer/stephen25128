"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const util_1 = require("util");
const sinon_1 = __importDefault(require("sinon"));
const node_dir_1 = __importDefault(require("node-dir"));
const chalk_1 = __importDefault(require("chalk"));
require("should");
const node_opcua_crypto_1 = require("node-opcua-crypto");
const helpers_1 = require("./helpers");
const lib_1 = require("../lib");
function copyFiles(sourceFolder, destinationFolder) {
    return __awaiter(this, void 0, void 0, function* () {
        const files = yield (0, util_1.promisify)(node_dir_1.default.files)(sourceFolder);
        for (const file of files) {
            const inputFilename = file;
            const baseName = path_1.default.basename(file);
            const outputFilename = path_1.default.join(destinationFolder, baseName);
            yield new Promise((resolve) => {
                fs_1.default.readFile(inputFilename, (err, data) => {
                    if (err) {
                        // tslint:disable-next-line: no-console
                        console.log(inputFilename);
                        resolve();
                        return;
                    }
                    fs_1.default.writeFile(outputFilename, data, () => {
                        resolve();
                    });
                });
            });
        }
    });
}
const copyFilesAsync = copyFiles;
function getCertificateList() {
    return __awaiter(this, void 0, void 0, function* () {
        const sourceFolder = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs");
        const files = yield (0, util_1.promisify)(node_dir_1.default.files)(sourceFolder);
        return files;
    });
}
var RSAFlags;
(function (RSAFlags) {
    RSAFlags[RSAFlags["UNKNOWN"] = 0] = "UNKNOWN";
    RSAFlags[RSAFlags["Sha1_1024"] = 1] = "Sha1_1024";
    RSAFlags[RSAFlags["Sha1_2048"] = 2] = "Sha1_2048";
    RSAFlags[RSAFlags["Sha256_2048"] = 3] = "Sha256_2048";
    RSAFlags[RSAFlags["Sha256_4096"] = 4] = "Sha256_4096";
})(RSAFlags || (RSAFlags = {}));
var TimeValidity;
(function (TimeValidity) {
    TimeValidity[TimeValidity["expired"] = 0] = "expired";
    TimeValidity[TimeValidity["not_yet_valid"] = 1] = "not_yet_valid";
    TimeValidity[TimeValidity["ok"] = 2] = "ok";
})(TimeValidity || (TimeValidity = {}));
function getFlags(filename) {
    const basename = path_1.default.basename(filename);
    const n = basename.replace(/ctt_.*app|ctt_.*usr|Sha1_1024|Sha1_2048|Sha256_2048|Sha256_4096|incorrect|ip|uri/g, "");
    const m = basename.match(/(Sha1_1024|Sha1_2048|Sha256_2048|Sha256_4096)/);
    const rsa = !m ? "" : m[1];
    const rsaFlag = RSAFlags[rsa] || RSAFlags.UNKNOWN;
    const certFlags = {
        trusted: !!n.match("T") ? true : n.match("U") ? false : undefined,
        validity: n.match("E") ? TimeValidity.expired : n.match("V") ? TimeValidity.not_yet_valid : TimeValidity.ok,
        manipulated: !!n.match("S") && !!filename.match("incorrect"),
        wrongCert: !!n.match("S") && !filename.match("incorrect"),
        revoked: !!n.match("R"),
    };
    function extractCaFlags(pattern) {
        const ca1str = basename.match(pattern + "([IUTC]+)");
        if (!ca1str) {
            return undefined;
        }
        const c = ca1str[1];
        return {
            trusted: c.match("T") ? true : c.match("U") ? false : undefined,
            revocationListUnknown: c.match("C") ? true : false,
            isIssuer: c.match("I") ? true : false,
        };
    }
    const ca1 = extractCaFlags("_ca1");
    const ca2 = extractCaFlags("_ca2");
    return { certFlags, rsaFlag, ca1, ca2 };
}
function legend() {
    function caFlagToString(r) {
        let ss = caFlag(r);
        if (r.isIssuer) {
            ss += ": is  an issuer";
        }
        else {
            ss += ": not an issuer";
        }
        if (r.trusted) {
            ss += ",   trusted ";
        }
        else if (r.trusted === false) {
            ss += ", untrusted ";
        }
        else {
            ss += ", never seen";
        }
        if (r.revocationListUnknown) {
            ss += ", without CRL";
        }
        else {
            ss += ", with a  CRL";
        }
        return ss;
    }
    const str1 = [];
    const p = " ".padEnd(11) + " ";
    str1.push("issuer certificate");
    str1.push(caFlagToString({ trusted: false, revocationListUnknown: true, isIssuer: false }));
    str1.push(caFlagToString({ trusted: true, revocationListUnknown: true, isIssuer: false }));
    str1.push(caFlagToString({ trusted: undefined, revocationListUnknown: true, isIssuer: false }));
    str1.push(caFlagToString({ trusted: false, revocationListUnknown: false, isIssuer: false }));
    str1.push(caFlagToString({ trusted: true, revocationListUnknown: false, isIssuer: false }));
    str1.push(caFlagToString({ trusted: undefined, revocationListUnknown: false, isIssuer: false }));
    str1.push(caFlagToString({ trusted: false, revocationListUnknown: true, isIssuer: true }));
    str1.push(caFlagToString({ trusted: true, revocationListUnknown: true, isIssuer: true }));
    str1.push(caFlagToString({ trusted: undefined, revocationListUnknown: true, isIssuer: true }));
    str1.push(caFlagToString({ trusted: false, revocationListUnknown: false, isIssuer: true }));
    str1.push(caFlagToString({ trusted: true, revocationListUnknown: false, isIssuer: true }));
    str1.push(caFlagToString({ trusted: undefined, revocationListUnknown: false, isIssuer: true }));
    return str1.map((a) => p + a).join("\n");
}
const pad = "---";
const pa0 = "   ";
function flagsHeader() {
    const str1 = [];
    str1.push("Root CA -------" + pad + "----------------------+"); //
    str1.push("Sub CA1 -------" + pad + "-----------------+    |"); // ðŸŸ¢ðŸ‘â›”ðŸŸ¢
    str1.push("Manipulated----" + pad + "------------+    |    |"); // ðŸ—±ðŸ˜ˆ
    str1.push("Revoked -------" + pad + "---------+  |    |    |"); // âŒ›â°ðŸ”œ
    str1.push("Validity-------" + pad + "------+  |  |    |    |"); // âŒ›â°ðŸ”œ
    str1.push("Trusted--------" + pad + "---+  |  |  |    |    |"); // ? | U | T
    str1.push("               " + pa0 + "   v  v  v  v |  v  | v "); // ðŸ‘â›”ðŸŸ¢
    const p = " ".padEnd(11) + " ";
    return str1.map((a) => p + a).join("\n");
}
function caFlag(c) {
    let str = "   ";
    if (!c) {
        return str;
    }
    const i = c.isIssuer ? chalk_1.default.yellow("I") : " ";
    const t = c.trusted === undefined ? " " : c.trusted ? chalk_1.default.green("T") : chalk_1.default.red("U");
    const r = c.revocationListUnknown ? chalk_1.default.magenta("C") : " ";
    str = `${i}${t}${r}`;
    return str;
}
function flagsToString(s) {
    const t = s.certFlags.trusted ? chalk_1.default.green("T") : chalk_1.default.red("U");
    const v = s.certFlags.validity === TimeValidity.expired
        ? chalk_1.default.red("E")
        : s.certFlags.validity === TimeValidity.not_yet_valid
            ? chalk_1.default.redBright("V")
            : chalk_1.default.green("âˆš");
    const r = s.certFlags.revoked ? chalk_1.default.magenta("R") : " ";
    const m = s.certFlags.manipulated ? chalk_1.default.red("$") : s.certFlags.wrongCert ? chalk_1.default.cyan("w") : " ";
    const ca1 = caFlag(s.ca1);
    const ca2 = caFlag(s.ca2);
    const x = "  " + pa0 + `   ${t}  ${v}  ${r}  ${m} | ${ca1} | ${ca2} `; // ðŸ‘â›”ðŸŸ¢
    return x;
}
/**
 * ctt = application instance certificate for the usage by the CTT.
 * ca1 = certificate authority of level 1 in the chain. Also called root ca.
 * caX = certificate authority of level X in the chain. E.g. 2 for secondary ca.
 * usr = user certificate which are used for X509 IdentityToken tests.
 * T = trusted by being placed in the trusted folder of the server.
 * U = untrusted by not being known to the server
 * I = issuers by being available in the issuers folder of the server (but may be not trusted)
 * C = revocation list unavailable which means the according revocation list is not available to the server
 * E = expired which means the validation time of the certificate has been exceeded
 * V = validity which means the certificate is not yet valid.
 * S = manipulated information ...
 * incorrect = incorrect signature by alternating bytes in the signature itself.
 * ip = incorrect ip.
 * sha1_1024 = certificate signed with the Sha1 algorithm and a key length of 1024 bit.
 * sha1_2048 = certificate signed with the Sha1 algorithm and a key length of 2048 bit.
 * sha256_2048 = certificate signed with the Sha256 algorithm and a key length of 2048 bit.
 * sha256_4096 = certificate signed with the Sha1 algorithm and a key length of 4096 bit.
 */
describe("testing CTT Certificate use cases", function () {
    this.timeout(2300000);
    const testData = (0, helpers_1.beforeTest)(this);
    let clock;
    beforeEach(() => {
        clock = sinon_1.default.useFakeTimers({
            now: new Date(2020, 4, 11),
            shouldAdvanceTime: true,
            advanceTimeDelta: 20,
        });
    });
    afterEach(() => {
        clock.restore();
    });
    before(() => __awaiter(this, void 0, void 0, function* () {
        fs_1.default.mkdirSync(path_1.default.join(testData.tmpFolder, "ctt"));
        const applicationPKI = new lib_1.CertificateManager({
            location: path_1.default.join(testData.tmpFolder, "ctt/applicationPKI"),
        });
        yield applicationPKI.initialize();
        const x509userIdentityPKI = new lib_1.CertificateManager({
            location: path_1.default.join(testData.tmpFolder, "ctt/userIdentityPKI"),
        });
        yield x509userIdentityPKI.initialize();
        // tslint:disable-next-line: no-console
        const promises = [];
        const rootApp = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/copyToServer/ApplicationInstance_PKI");
        const rootUI = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/copyToServer/X509UserIdentity_PKI");
        promises.push(copyFilesAsync(path_1.default.join(rootApp, "issuers/certs"), applicationPKI.issuersCertFolder));
        promises.push(copyFilesAsync(path_1.default.join(rootApp, "issuers/crl"), applicationPKI.issuersCrlFolder));
        promises.push(copyFilesAsync(path_1.default.join(rootApp, "trusted/certs"), applicationPKI.trustedFolder));
        promises.push(copyFilesAsync(path_1.default.join(rootApp, "trusted/crl"), applicationPKI.crlFolder));
        promises.push(copyFilesAsync(path_1.default.join(rootUI, "issuers/certs"), x509userIdentityPKI.issuersCertFolder));
        promises.push(copyFilesAsync(path_1.default.join(rootUI, "issuers/crl"), x509userIdentityPKI.issuersCrlFolder));
        promises.push(copyFilesAsync(path_1.default.join(rootUI, "trusted/certs"), x509userIdentityPKI.trustedFolder));
        promises.push(copyFilesAsync(path_1.default.join(rootUI, "trusted/crl"), x509userIdentityPKI.crlFolder));
        yield Promise.all(promises);
        // tslint:disable-next-line: no-console
        console.log(legend());
        // tslint:disable-next-line: no-console
        console.log(flagsHeader());
        yield applicationPKI.dispose();
        yield x509userIdentityPKI.dispose();
    }));
    function test_verify(certFilename, certificateManager) {
        return __awaiter(this, void 0, void 0, function* () {
            const certificate = (0, node_opcua_crypto_1.readCertificate)(certFilename);
            const nbInChain = (0, node_opcua_crypto_1.split_der)(certificate).length;
            const status = yield certificateManager.verifyCertificate(certificate);
            const flags = getFlags(certFilename);
            // tslint:disable-next-line: no-console
            console.log(path_1.default.basename(certFilename).padEnd(24), flagsToString(flags), status.toString().padEnd(37), nbInChain, (0, node_opcua_crypto_1.makeSHA1Thumbprint)(certificate).toString("hex").substring(0, 10));
            if (flags.certFlags.validity === TimeValidity.expired || flags.certFlags.validity === TimeValidity.not_yet_valid) {
                if (flags.certFlags.trusted) {
                    status.should.eql(lib_1.VerificationStatus.BadCertificateTimeInvalid);
                }
                else {
                    status.should.eql(lib_1.VerificationStatus.BadCertificateUntrusted);
                }
            }
            if (flags.ca2 && flags.ca2.trusted === false) {
                status.should.eql("BadCertificateChainIncomplete"); // Issuer not known
            }
            if (!flags.certFlags.trusted && flags.certFlags.validity === TimeValidity.ok && !flags.ca1 && !flags.ca2) {
                status.should.eql("BadCertificateUntrusted");
            }
            return { status, nbInChain, certificate };
        });
    }
    describe("with applicationPKI", () => {
        let applicationPKI;
        before(() => __awaiter(this, void 0, void 0, function* () {
            applicationPKI = new lib_1.CertificateManager({
                location: path_1.default.join(testData.tmpFolder, "ctt/applicationPKI"),
            });
            yield applicationPKI.initialize();
        }));
        after(() => __awaiter(this, void 0, void 0, function* () {
            yield applicationPKI.dispose();
        }));
        it("A1: ctt_ca1TC_ca2I_appT : trusted X509 user certificate of a ca not trusted but known should be OK", () => __awaiter(this, void 0, void 0, function* () {
            const file1 = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1TC_ca2I_appT.der");
            const { status } = yield test_verify(file1, applicationPKI);
            status.should.eql(lib_1.VerificationStatus.BadCertificateIssuerRevocationUnknown);
        }));
        it("A2: ctt_appUE : Expired & not trusted => Not Trusted should prevail", () => __awaiter(this, void 0, void 0, function* () {
            const file1 = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_appUE.der");
            const { status } = yield test_verify(file1, applicationPKI);
            status.should.eql(lib_1.VerificationStatus.BadCertificateUntrusted);
        }));
        it("A3: ctt_ca1TC_appT : using an (trusted) issued certificate of a CA that has no revocation list available.", () => __awaiter(this, void 0, void 0, function* () {
            const file1 = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1TC_appT.der");
            const { status } = yield test_verify(file1, applicationPKI);
            status.should.eql(lib_1.VerificationStatus.BadCertificateRevocationUnknown);
        }));
        it("XGXG1 verifying all sort of application certificates", () => __awaiter(this, void 0, void 0, function* () {
            const list = yield getCertificateList();
            const applicationCertificates = list.filter((f) => path_1.default.basename(f).match(/^ctt_.*app/));
            const file2 = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1I_ca2T_appU.der");
            yield test_verify(file2, applicationPKI);
            // tslint:disable-next-line: no-console
            for (const certFilename of applicationCertificates) {
                yield test_verify(certFilename, applicationPKI);
            }
        }));
    });
    describe("with x509userIdentityPKI", () => {
        let x509userIdentityPKI;
        before(() => __awaiter(this, void 0, void 0, function* () {
            x509userIdentityPKI = new lib_1.CertificateManager({
                location: path_1.default.join(testData.tmpFolder, "ctt/userIdentityPKI"),
            });
            yield x509userIdentityPKI.initialize();
        }));
        after(() => __awaiter(this, void 0, void 0, function* () {
            yield x509userIdentityPKI.dispose();
        }));
        it("T1: ctt_ca1I_usrT : trusted X509 user certificate of a ca not trusted but known should be OK", () => __awaiter(this, void 0, void 0, function* () {
            const file1 = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1I_usrT.der");
            const { status } = yield test_verify(file1, x509userIdentityPKI);
            status.should.eql(lib_1.VerificationStatus.Good);
        }));
        it("T2: ctt_ca1I_usrU : untrusted X509 user certificate of a ca not trusted but known should fail", () => __awaiter(this, void 0, void 0, function* () {
            const file1 = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1I_usrU.der");
            const { status } = yield test_verify(file1, x509userIdentityPKI);
            status.should.eql(lib_1.VerificationStatus.BadCertificateUntrusted);
        }));
        it("T3: ctt_ca1IC_usrT : trusted X509 user certificate of a ca not trusted but known, that have no revocation list should fail", () => __awaiter(this, void 0, void 0, function* () {
            const file1 = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1IC_usrT.der");
            const { status } = yield test_verify(file1, x509userIdentityPKI);
            status.should.eql(lib_1.VerificationStatus.BadCertificateRevocationUnknown);
        }));
        // const file1 = path.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1I_usrU.der");
        //const file1 = path.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1IC_usrT.der");
        // const file1 = path.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1TC_ca2I_appT.der");
        it("XGXG2 verifying all sort of user certificates ", () => __awaiter(this, void 0, void 0, function* () {
            const list = yield getCertificateList();
            const applicationCertificates = list.filter((f) => path_1.default.basename(f).match(/^ctt_.*usr/));
            // tslint:disable-next-line: no-console
            console.log(flagsHeader());
            const file1 = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1I_usrT.der");
            // const file1 = path.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1I_usrU.der");
            //const file1 = path.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1IC_usrT.der");
            // const file1 = path.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1TC_ca2I_appT.der");
            yield test_verify(file1, x509userIdentityPKI);
            for (const certFilename of applicationCertificates) {
                yield test_verify(certFilename, x509userIdentityPKI);
            }
        }));
    });
    it("XGXG3 should check for revoked certificates", () => __awaiter(this, void 0, void 0, function* () {
        // ctt_ca1I_ca2T_usrTR.der
        const applicationPKI = new lib_1.CertificateManager({
            location: path_1.default.join(testData.tmpFolder, "ctt/applicationPKI"),
        });
        yield applicationPKI.initialize();
        const file1 = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1I_ca2T_appU.der");
        const file2R = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1I_ca2T_usrTR.der");
        const file3 = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1TC_ca2I_appT.der");
        const cert1 = yield (0, node_opcua_crypto_1.readCertificate)(file1);
        (yield applicationPKI.isCertificateRevoked(cert1)).should.eql("Good");
        const cert2R = yield (0, node_opcua_crypto_1.readCertificate)(file2R);
        const isRevoked2 = yield applicationPKI.isCertificateRevoked(cert2R);
        isRevoked2.should.eql(lib_1.VerificationStatus.BadCertificateRevoked);
        yield applicationPKI.dispose();
    }));
    it("XGXG4 debug", () => __awaiter(this, void 0, void 0, function* () {
        const applicationPKI = new lib_1.CertificateManager({
            location: path_1.default.join(testData.tmpFolder, "ctt/applicationPKI"),
        });
        yield applicationPKI.initialize();
        const file1 = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1TC_ca2I_appT.der");
        const certificate = yield (0, node_opcua_crypto_1.readCertificate)(file1);
        (yield applicationPKI.isCertificateRevoked(certificate)).should.eql("Good");
        const status = yield applicationPKI.verifyCertificate(certificate);
        status.should.eql(lib_1.VerificationStatus.BadCertificateIssuerRevocationUnknown);
        yield applicationPKI.dispose();
    }));
    it("XGXG5 debug", () => __awaiter(this, void 0, void 0, function* () {
        const userPKI = new lib_1.CertificateManager({
            location: path_1.default.join(testData.tmpFolder, "ctt/userIdentityPKI"),
        });
        yield userPKI.initialize();
        const file1 = path_1.default.join(__dirname, "fixtures/CTT_sample_certificates/CA/certs/ctt_ca1I_usrU.der");
        const certificate = yield (0, node_opcua_crypto_1.readCertificate)(file1);
        (yield userPKI.isCertificateRevoked(certificate)).should.eql(lib_1.VerificationStatus.Good);
        const status = yield userPKI.verifyCertificate(certificate);
        status.should.eql(lib_1.VerificationStatus.BadCertificateUntrusted); //
        yield userPKI.dispose();
    }));
});
//# sourceMappingURL=test_ctt_use_cases.js.map