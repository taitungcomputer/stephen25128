"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
Error.stackTraceLimit = Infinity;
// tslint:disable: no-console
// tslint:disable:variable-name
// tslint:disable:no-shadowed-variable
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
require("should");
const node_opcua_crypto_1 = require("node-opcua-crypto");
const helpers_1 = require("./helpers");
const lib_1 = require("../lib");
const with_openssl_1 = require("../lib/toolbox/with_openssl");
const q = lib_1.quote;
const n = lib_1.makePath;
describe("CertificateManager", function () {
    this.timeout(40000);
    const testData = (0, helpers_1.beforeTest)(this);
    it("should create a certificateManager", () => __awaiter(this, void 0, void 0, function* () {
        const options = {
            location: path_1.default.join(testData.tmpFolder, "PKI"),
        };
        const cm = new lib_1.CertificateManager(options);
        yield cm.initialize();
        fs_1.default.existsSync(path_1.default.join(options.location)).should.eql(true);
        fs_1.default.existsSync(path_1.default.join(options.location, "trusted")).should.eql(true);
        fs_1.default.existsSync(path_1.default.join(options.location, "rejected")).should.eql(true);
        fs_1.default.existsSync(path_1.default.join(options.location, "own")).should.eql(true);
        fs_1.default.existsSync(path_1.default.join(options.location, "own/certs")).should.eql(true);
        fs_1.default.existsSync(path_1.default.join(options.location, "own/private")).should.eql(true);
        fs_1.default.existsSync(path_1.default.join(options.location, "own/openssl.cnf")).should.eql(true);
        fs_1.default.existsSync(path_1.default.join(options.location, "own/private/private_key.pem")).should.eql(true);
        const data = fs_1.default.readFileSync(path_1.default.join(options.location, "own/openssl.cnf"), "ascii");
        // config file must have a distinguish name section
        (0, helpers_1.grep)(data, /distinguished_name/).should.match(/distinguished_name/);
        yield cm.dispose();
    }));
    it("should create its own self-signed certificate", () => __awaiter(this, void 0, void 0, function* () {
        function get_days(date1, date2) {
            const ms_in_one_day = 24 * 3600000;
            const diff = date1.getTime() - date2.getTime();
            return Math.round(diff / ms_in_one_day);
        }
        const options = {
            location: path_1.default.join(testData.tmpFolder, "PKI1"),
        };
        const cm = new lib_1.CertificateManager(options);
        yield cm.initialize();
        const now = new Date();
        const endDate = new Date(now.getFullYear() + 7, 10, 10);
        const duration = get_days(endDate, now);
        const params = {
            applicationUri: "MY:APPLICATION:URI",
            dns: ["some.other.domain.com", "my.domain.com"],
            ip: ["192.123.145.121"],
            subject: "CN=MyCommonName",
            // can only be TODAY due to openssl limitation : startDate: new Date(2010,2,2),
            validity: duration,
            startDate: now,
        };
        yield cm.createSelfSignedCertificate(params);
        const expectedCertificate = path_1.default.join(options.location, "own/certs/self_signed_certificate.pem");
        fs_1.default.existsSync(expectedCertificate).should.eql(true, "self-signed certificate must exist");
        const data = yield (0, with_openssl_1.dumpCertificate)(expectedCertificate);
        yield fs_1.default.promises.writeFile(path_1.default.join(testData.tmpFolder, "dump_cert1.txt"), data);
        (0, helpers_1.grep)(data, /URI/).should.match(/URI:MY:APPLICATION:URI/);
        (0, helpers_1.grep)(data, /DNS/).should.match(/DNS:some.other.domain.com/);
        (0, helpers_1.grep)(data, /DNS/).should.match(/DNS:my.domain.com/);
        if (lib_1.g_config.opensslVersion.match(/1.0.2/)) {
            // note openssl version 1.0.1 does support sha256 signature
            (0, helpers_1.grep)(data, /Signature Algorithm/).should.match(/Signature Algorithm: sha256WithRSAEncryption/);
        }
        (0, helpers_1.grep)(data, /Self-signed/).should.match(/Self-signed/);
        // the self-signed certificate should contain
        //     Digital Signature, Non Repudiation, Key Encipherment, Data Encipherment, Key Agreement
        (0, helpers_1.grep)(data, /Digital Signature/).should.match(/Digital Signature/);
        (0, helpers_1.grep)(data, /Key Encipherment/).should.match(/Key Encipherment/);
        (0, helpers_1.grep)(data, /Data Encipherment/).should.match(/Data Encipherment/);
        // the self-signed certificate should not contain CRL Sign
        (0, helpers_1.grep)(data, /CRL Sign/).should.eql("");
        const y = new Date().getFullYear();
        (0, helpers_1.grep)(data, /Not Before/).should.match(new RegExp(y.toString() + " GMT"));
        (0, helpers_1.grep)(data, /Not After/).should.match(new RegExp((y + 7).toString() + " GMT"));
        yield cm.dispose();
    }));
});
describe("CertificateManager managing certificate", function () {
    this.timeout(400000);
    const testData = (0, helpers_1.beforeTest)(this);
    let cm;
    function createSampleCertificateDer(certificate) {
        return __awaiter(this, void 0, void 0, function* () {
            (0, with_openssl_1.processAltNames)({ applicationUri: "T" });
            const defaultOpensslConfPath = path_1.default.join(__dirname, "../tmp/PKI2/own/openssl.cnf");
            const defaultOpensslConf = (0, with_openssl_1.generateStaticConfig)(defaultOpensslConfPath);
            certificate = (0, lib_1.makePath)(certificate);
            // openssl req -x509 -days 365 -nodes -newkey rsa:1024 \
            //         -keyout private_key.pem -outform der -out certificate.der"
            yield (0, with_openssl_1.executeOpensslAsync)("req " +
                "-x509 -days 365 -nodes -newkey rsa:1024 " +
                "-batch -keyout private_key.pem " +
                "-outform der -out " +
                q(n(certificate)) +
                " -config " +
                q(n(defaultOpensslConf)), {});
        });
    }
    const sample_certificate1_der = path_1.default.join(__dirname, "fixtures/sample_certificate1.der");
    const sample_certificate2_der = path_1.default.join(__dirname, "fixtures/sample_certificate2.der");
    const sample_certificate3_der = path_1.default.join(__dirname, "fixtures/sample_certificate3.der");
    const sample_certificate4_der = path_1.default.join(__dirname, "fixtures/sample_certificate4.der");
    before(() => __awaiter(this, void 0, void 0, function* () {
        const options = {
            location: path_1.default.join(testData.tmpFolder, "PKI2"),
        };
        cm = new lib_1.CertificateManager(options);
        yield cm.initialize();
        yield createSampleCertificateDer(sample_certificate1_der);
        yield createSampleCertificateDer(sample_certificate2_der);
        yield createSampleCertificateDer(sample_certificate3_der);
        yield createSampleCertificateDer(sample_certificate4_der);
        yield cm.dispose();
    }));
    it("Q1 - CertificateManager#_getCertificateStatus should return 'unknown' if the certificate is first seen", () => __awaiter(this, void 0, void 0, function* () {
        const certificate = fs_1.default.readFileSync(sample_certificate1_der);
        certificate.should.be.instanceOf(Buffer);
        yield (0, with_openssl_1.executeOpensslAsync)("x509 -inform der -in " + q(n(sample_certificate1_der)) + " " + "-fingerprint -noout ", {});
        const status = yield cm._checkRejectedOrTrusted(certificate);
        status.should.eql("unknown");
    }));
    it("Q2 - CertificateManager#getCertificateStatus should store unknown certificate into the untrusted folder", () => __awaiter(this, void 0, void 0, function* () {
        const certificate = fs_1.default.readFileSync(sample_certificate2_der);
        const status1 = yield cm.getCertificateStatus(certificate);
        status1.should.eql("rejected");
        const status2 = yield cm.getCertificateStatus(certificate);
        status2.should.eql("rejected");
    }));
    it("Q3 - CertificateManager#trustCertificate should store in trusted folder", () => __awaiter(this, void 0, void 0, function* () {
        const certificate = fs_1.default.readFileSync(sample_certificate3_der);
        const status1 = yield cm.getCertificateStatus(certificate);
        status1.should.eql("rejected");
        yield cm.trustCertificate(certificate);
        const status2 = yield cm.getCertificateStatus(certificate);
        status2.should.eql("trusted");
        yield cm.rejectCertificate(certificate);
        const status3 = yield cm.getCertificateStatus(certificate);
        status3.should.eql("rejected");
        yield cm.rejectCertificate(certificate);
    }));
    it("Q4 - Async CertificateManager#trustCertificate  should store in trusted folder", () => __awaiter(this, void 0, void 0, function* () {
        const fsReadFile = fs_1.default.promises.readFile;
        const certificate = yield fsReadFile(sample_certificate3_der);
        const status = yield cm.getCertificateStatus(certificate);
        status.should.eql("rejected");
        yield cm.trustCertificate(certificate);
        const status1 = yield cm.getCertificateStatus(certificate);
        status1.should.eql("trusted");
        const status1_a = yield cm.isCertificateTrusted(certificate);
        status1_a.should.eql("Good");
        yield cm.rejectCertificate(certificate);
        const status2 = yield cm.getCertificateStatus(certificate);
        status2.should.eql("rejected");
        const status2_a = yield cm.isCertificateTrusted(certificate);
        status2_a.should.eql("BadCertificateUntrusted");
        yield cm.rejectCertificate(certificate);
    }));
    it("Q5 - isCertificateTrusted with invalid certificate", () => __awaiter(this, void 0, void 0, function* () {
        const badCertificate = Buffer.from("bad certificate");
        const status2_a = yield cm.isCertificateTrusted(badCertificate);
        status2_a.should.eql("BadCertificateInvalid");
    }));
    it("Q6 - isCertificateTrusted", () => __awaiter(this, void 0, void 0, function* () {
        const fsReadFile = fs_1.default.promises.readFile;
        const certificate = yield fsReadFile(sample_certificate3_der);
        const status = yield cm.isCertificateTrusted(certificate);
        status.should.eql("BadCertificateUntrusted");
        yield cm.trustCertificate(certificate);
        const status1 = yield cm.isCertificateTrusted(certificate);
        status1.should.eql("Good");
        yield cm.rejectCertificate(certificate);
        const status2 = yield cm.isCertificateTrusted(certificate);
        status2.should.eql("BadCertificateUntrusted");
        yield cm.rejectCertificate(certificate);
    }));
    it("Q7 - Checking certificate", () => __awaiter(this, void 0, void 0, function* () {
        yield cm.initialize();
        const sample_certificate3_pem = path_1.default.join(__dirname, "fixtures/sample_server_selfSigned1.pem");
        const certificate = yield (0, node_opcua_crypto_1.readCertificate)(sample_certificate3_pem);
        yield cm.trustCertificate(certificate);
        const status = yield cm.getCertificateStatus(certificate);
        console.log("status ", status.toString());
        const verificationStatus = yield cm.verifyCertificate(certificate);
        console.log("status ", verificationStatus.toString());
    }));
    it("Q8A - Disposing while initializing ", () => __awaiter(this, void 0, void 0, function* () {
        const options = {
            location: path_1.default.join(testData.tmpFolder, "PKI_aa"),
        };
        const cm = new lib_1.CertificateManager(options);
        yield cm.initialize();
        console.log("initialized done");
        cm.dispose();
    }));
    it("Q8B - Disposing while initializing ", () => __awaiter(this, void 0, void 0, function* () {
        const options = {
            location: path_1.default.join(testData.tmpFolder, "PKI_aa"),
        };
        const cm = new lib_1.CertificateManager(options);
        const promises = [
            (() => __awaiter(this, void 0, void 0, function* () {
                yield cm.initialize();
                console.log("initialized done");
            }))(),
            (() => __awaiter(this, void 0, void 0, function* () {
                yield new Promise((resolve) => {
                    setImmediate(() => {
                        cm.dispose();
                        console.log("disposed");
                        resolve();
                    });
                });
            }))()
        ];
        yield Promise.all(promises);
    }));
});
//# sourceMappingURL=test_certificate_manager.js.map