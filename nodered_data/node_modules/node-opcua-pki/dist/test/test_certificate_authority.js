"use strict";
// tslint:disable:no-console
// tslint:disable:no-shadowed-variable
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const node_opcua_crypto_1 = require("node-opcua-crypto");
const index_1 = require("../lib/index");
const with_openssl_1 = require("../lib/toolbox/with_openssl");
const certificate_authority_1 = require("../lib/ca/certificate_authority");
const helpers_1 = require("./helpers");
const doDebug = !!process.env.DEBUG;
describe("Certificate Authority", function () {
    const testData = (0, helpers_1.beforeTest)(this);
    let options = {};
    before(() => {
        options = {
            keySize: 2048,
            location: path_1.default.join(testData.tmpFolder, "CA"),
        };
    });
    it("should read openssl version", () => __awaiter(this, void 0, void 0, function* () {
        let output = yield (0, with_openssl_1.execute_openssl)("version", { cwd: "." });
        output = output.trim();
        index_1.g_config.opensslVersion.should.eql(output);
    }));
    it("should create a CertificateAuthority", () => __awaiter(this, void 0, void 0, function* () {
        const ca = new certificate_authority_1.CertificateAuthority(options);
        yield ca.initialize();
    }));
});
describe("Signing Certificate with Certificate Authority", function () {
    const testData = (0, helpers_1.beforeTest)(this);
    let theCertificateAuthority;
    let someCertificateManager;
    before(() => __awaiter(this, void 0, void 0, function* () {
        theCertificateAuthority = new certificate_authority_1.CertificateAuthority({
            keySize: 2048,
            location: path_1.default.join(testData.tmpFolder, "CA"),
        });
        someCertificateManager = new index_1.CertificateManager({
            location: path_1.default.join(testData.tmpFolder, "PI"),
        });
        yield someCertificateManager.initialize();
        yield theCertificateAuthority.initialize();
        yield someCertificateManager.dispose();
    }));
    function createCertificateRequest() {
        return __awaiter(this, void 0, void 0, function* () {
            // let create a certificate request from the certificate manager
            const params = {
                applicationUri: "MY:APPLICATION:URI",
                dns: ["localhost", "my.domain.com"],
                ip: ["192.123.145.121"],
                subject: "/CN=MyCommonName",
                // can only be TODAY due to openssl limitation : startDate: new Date(2010,2,2),
                validity: 365 * 7,
            };
            const certificateSigningRequestFilename = yield someCertificateManager.createCertificateRequest(params);
            return certificateSigningRequestFilename;
        });
    }
    function verifyCertificateAgainstPrivateKey(certificate) {
        return __awaiter(this, void 0, void 0, function* () {
            console.log("someCertificateManager.privateKey=", someCertificateManager.privateKey);
            const privateKey = (0, node_opcua_crypto_1.readPrivateKey)(someCertificateManager.privateKey);
            const rsaLength = (0, node_opcua_crypto_1.rsaLengthPrivateKey)(privateKey);
            if (!(0, node_opcua_crypto_1.certificateMatchesPrivateKey)(certificate, privateKey)) {
                throw new Error("Certificate and private key do not match !!!");
            }
        });
    }
    it("T0 - should have a CA Certificate", () => __awaiter(this, void 0, void 0, function* () {
        fs_1.default.existsSync(theCertificateAuthority.caCertificate).should.eql(true);
    }));
    it("T1 - should have a CA Certificate with a CRL", () => __awaiter(this, void 0, void 0, function* () {
        yield theCertificateAuthority.constructCACertificateWithCRL();
        fs_1.default.existsSync(theCertificateAuthority.caCertificateWithCrl).should.eql(true);
    }));
    it("T2 - should sign a Certificate Request", () => __awaiter(this, void 0, void 0, function* () {
        const self = {
            certificateRequest: "",
        };
        // create a Certificate Signing Request
        self.certificateRequest = yield createCertificateRequest();
        fs_1.default.existsSync(self.certificateRequest).should.eql(true);
        const certificateFilename = path_1.default.join(testData.tmpFolder, "sample_certificate.pem");
        const params = {
            applicationUri: "BAD SHOULD BE IN REQUEST",
            startDate: new Date(2011, 25, 12),
            validity: 10 * 365,
        };
        yield theCertificateAuthority.signCertificateRequest(certificateFilename, self.certificateRequest, params);
        fs_1.default.existsSync(certificateFilename).should.eql(true, "certificate file " + certificateFilename + " must exist");
        // Serial Number: 4096 (0x1000)
        const certificateChain = (0, node_opcua_crypto_1.readCertificate)(certificateFilename);
        const elements = (0, node_opcua_crypto_1.split_der)(certificateChain);
        elements.length.should.eql(2);
        // should have 2 x -----BEGIN CERTIFICATE----- in the chain
        // should verify that certificate is valid
        // verify the subject Alternative Name
        const csr = (0, node_opcua_crypto_1.readCertificate)(self.certificateRequest);
        const infoCSR = (0, node_opcua_crypto_1.exploreCertificateSigningRequest)(csr);
        const info = (0, node_opcua_crypto_1.exploreCertificate)(certificateChain);
        if (doDebug) {
            console.log(infoCSR.extensionRequest.basicConstraints);
            console.log(info.tbsCertificate.extensions.basicConstraints);
            console.log(infoCSR.extensionRequest.keyUsage);
            console.log(info.tbsCertificate.extensions.keyUsage);
            console.log(infoCSR.extensionRequest.subjectAltName);
            console.log(info.tbsCertificate.extensions.subjectAltName);
        }
        infoCSR.extensionRequest.subjectAltName.should.eql(info.tbsCertificate.extensions.subjectAltName);
        // todo
        yield verifyCertificateAgainstPrivateKey(elements[0]);
    }));
    function sign(certificateRequest, startDate, validity) {
        return __awaiter(this, void 0, void 0, function* () {
            const a = (0, with_openssl_1.x509Date)(startDate) + "_" + validity;
            fs_1.default.existsSync(certificateRequest).should.eql(true, "certificate request " + certificateRequest + " must exist");
            const certificateFilename = path_1.default.join(testData.tmpFolder, "sample_certificate" + a + ".pem");
            const params = {
                applicationUri: "BAD SHOULD BE IN REQUEST",
                startDate,
                validity,
            };
            if (fs_1.default.existsSync(certificateFilename)) {
                fs_1.default.unlinkSync(certificateFilename);
            }
            const certificate = yield theCertificateAuthority.signCertificateRequest(certificateFilename, certificateRequest, params);
            fs_1.default.existsSync(certificate).should.eql(true, "certificate: " + certificateFilename + " should exists");
            // Serial Number: 4096 (0x1000)
            // should have 2 x -----BEGIN CERTIFICATE----- in the chain
            return certificate;
        });
    }
    const now = new Date();
    const lastYear = new Date();
    lastYear.setFullYear(now.getFullYear() - 1);
    const nextYear = new Date();
    nextYear.setFullYear(now.getFullYear() + 1);
    it("T3 - should create various Certificates signed by the CA authority", () => __awaiter(this, void 0, void 0, function* () {
        // create a Certificate Signing Request
        const certificateRequest = yield createCertificateRequest();
        fs_1.default.existsSync(certificateRequest).should.eql(true, "certificate request " + certificateRequest + " must exist");
        yield sign(certificateRequest, lastYear, 200);
        yield sign(certificateRequest, lastYear, 10 * 365); // valid
        yield sign(certificateRequest, nextYear, 365); // not started yet
    }));
    it("T4 - should create various self-signed Certificates using the CA", () => __awaiter(this, void 0, void 0, function* () {
        // using a CA to construct self-signed certificates provides the following benefits:
        //    - startDate can be easily specified in the past or the future
        //    - certificate can be revoked ??? to be checked.
        const privateKey = someCertificateManager.privateKey;
        const certificate = path_1.default.join(testData.tmpFolder, "sample_self_signed_certificate.pem");
        fs_1.default.existsSync(certificate).should.eql(false, certificate + " must not exist");
        yield theCertificateAuthority.createSelfSignedCertificate(certificate, privateKey, {
            applicationUri: "SomeUri",
        });
        fs_1.default.existsSync(certificate).should.eql(true);
        yield verifyCertificateAgainstPrivateKey((0, node_opcua_crypto_1.readCertificate)(certificate));
    }));
    /**
     *
     * @param certificate  {String} certificate to create
     */
    function createSelfSignedCertificate(certificate, privateKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const startDate = new Date();
            const validity = 1000;
            const params = {
                applicationUri: "BAD SHOULD BE IN REQUEST",
                startDate,
                validity,
            };
            yield theCertificateAuthority.createSelfSignedCertificate(certificate, privateKey, params);
            // console.log("signed_certificate = signed_certificate", certificate);
            return certificate;
        });
    }
    it("T5 - should revoke a self-signed certificate", () => __awaiter(this, void 0, void 0, function* () {
        const privateKey = someCertificateManager.privateKey;
        const certificate = path_1.default.join(testData.tmpFolder, "certificate_to_be_revoked1.pem");
        yield createSelfSignedCertificate(certificate, privateKey);
        fs_1.default.existsSync(certificate).should.eql(true);
        yield theCertificateAuthority.revokeCertificate(certificate, {});
    }));
    function createCertificateFromCA() {
        return __awaiter(this, void 0, void 0, function* () {
            const certificateRequest = yield createCertificateRequest();
            const signedCertificate = yield sign(certificateRequest, lastYear, 10 * 365 + 10);
            return signedCertificate;
        });
    }
    it("T6 - should revoke a certificate emitted by the CA", () => __awaiter(this, void 0, void 0, function* () {
        // g_config.silent = false;
        const caCertificateFilename = theCertificateAuthority.caCertificate;
        const caCRLFilename = theCertificateAuthority.revocationList;
        const caCertificate = yield (0, node_opcua_crypto_1.readCertificate)(caCertificateFilename);
        const caCRLBefore = yield (0, node_opcua_crypto_1.readCertificateRevocationList)(caCRLFilename);
        const certificateFilename = yield createCertificateFromCA();
        fs_1.default.existsSync(certificateFilename).should.eql(true);
        const certificate = yield (0, node_opcua_crypto_1.readCertificate)(certificateFilename);
        // ---- lets create a
        const pkiLocation = path_1.default.join(testData.tmpFolder, "somePKI");
        const cm = new index_1.CertificateManager({
            location: pkiLocation,
        });
        yield cm.initialize();
        const status1 = yield cm.addIssuer(caCertificate, true, true);
        status1.should.eql(index_1.VerificationStatus.Good);
        const status4 = yield cm.addRevocationList(caCRLBefore);
        status4.should.eql(index_1.VerificationStatus.Good);
        // check status before revocation...
        const validate1 = yield cm.verifyCertificate(certificate);
        validate1.should.eql(index_1.VerificationStatus.Good);
        // now revoke certificate
        yield theCertificateAuthority.revokeCertificate(certificateFilename, {});
        const caCRLAfter = yield (0, node_opcua_crypto_1.readCertificateRevocationList)(caCRLFilename);
        const status3 = yield cm.addRevocationList(caCRLAfter);
        status3.should.eql(index_1.VerificationStatus.Good);
        const validate2 = yield cm.verifyCertificate(certificate);
        validate2.should.eql(index_1.VerificationStatus.BadCertificateRevoked);
        yield cm.dispose();
    }));
    it("T7 - it should automatically accept Certificate issued by a trusted issuer that is not in the CRL", () => __awaiter(this, void 0, void 0, function* () {
        const caCertificateFilename = theCertificateAuthority.caCertificate;
        const caCRLFilename = theCertificateAuthority.revocationList;
        const caCertificate = yield (0, node_opcua_crypto_1.readCertificate)(caCertificateFilename);
        const caCRLBefore = yield (0, node_opcua_crypto_1.readCertificateRevocationList)(caCRLFilename);
        const certificateFilename = yield createCertificateFromCA();
        fs_1.default.existsSync(certificateFilename).should.eql(true);
        const certificate = yield (0, node_opcua_crypto_1.readCertificate)(certificateFilename);
        // ---- lets create a
        const pkiLocation = path_1.default.join(testData.tmpFolder, "somePKI1");
        const cm = new index_1.CertificateManager({
            location: pkiLocation,
        });
        yield cm.initialize();
        const validate0 = yield cm.verifyCertificate(certificate);
        validate0.should.eql(index_1.VerificationStatus.BadCertificateChainIncomplete);
        const status1 = yield cm.addIssuer(caCertificate);
        const status2 = yield cm.addRevocationList(caCRLBefore);
        const validate1 = yield cm.verifyCertificate(certificate);
        validate1.should.eql(index_1.VerificationStatus.BadCertificateUntrusted);
        yield cm.dispose();
    }));
});
//# sourceMappingURL=test_certificate_authority.js.map