"use strict";
// tslint:disable:variable-name
// tslint:disable:no-shadowed-variable
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
Error.stackTraceLimit = Infinity;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
require("should");
const node_opcua_crypto_1 = require("node-opcua-crypto");
const lib_1 = require("../lib/");
const ca_1 = require("../lib/ca");
const helpers_1 = require("./helpers");
// ------------------------------------------------- some useful dates
function get_offset_date(date, nb_days) {
    const d = new Date(date.getTime());
    d.setDate(d.getDate() + nb_days);
    return d;
}
const today = new Date();
const lastYear = get_offset_date(today, -365);
const nextYear = get_offset_date(today, 365);
const yesterday = get_offset_date(today, -1);
describe("test certificate validation", function () {
    let certificateAuthority;
    let otherCertificateAuthority;
    let certificate_out_of_date;
    let certificate_not_yet_active;
    let certificate_valid;
    let certificate_valid_untrusted;
    let certificate_valid_signed_with_other_CA;
    const testData = (0, helpers_1.beforeTest)(this);
    let certificateManager;
    /**
     * @method createCertificate
     */
    function createSignedCertificate(certificate, params, certificateAuthority) {
        return __awaiter(this, void 0, void 0, function* () {
            // create a signing request
            const theCertificateRequest = yield certificateManager.createCertificateRequest(params);
            fs_1.default.existsSync(certificate).should.eql(false, certificate + " should not exist");
            fs_1.default.existsSync(theCertificateRequest).should.eql(true);
            // ask the Certificate Authority to sign the certificate
            yield certificateAuthority.signCertificateRequest(certificate, theCertificateRequest, params);
            fs_1.default.existsSync(theCertificateRequest).should.eql(true);
            fs_1.default.existsSync(certificate).should.eql(true);
        });
    }
    before(() => __awaiter(this, void 0, void 0, function* () {
        const optionsCA = {
            keySize: 2048,
            location: path_1.default.join(testData.tmpFolder, "TEST_CA"),
        };
        certificateAuthority = new ca_1.CertificateAuthority(optionsCA);
        yield certificateAuthority.initialize();
        // create an other certificate authority
        otherCertificateAuthority = new ca_1.CertificateAuthority({
            keySize: 2048,
            location: path_1.default.join(testData.tmpFolder, "OTHER_CA"),
        });
        yield otherCertificateAuthority.initialize();
        const optionsPKI = { location: path_1.default.join(testData.tmpFolder, "TEST_PKI") };
        certificateManager = new lib_1.CertificateManager(optionsPKI);
        yield certificateManager.initialize();
        const subject = {
            commonName: "MyCompany",
            country: "FR",
            locality: "Paris",
            organization: "whateverCorp",
            state: "Mainland",
            domainComponent: "aaa",
        };
        certificate_out_of_date = path_1.default.join(testData.tmpFolder, "certificate_out_of_date.pem");
        yield createSignedCertificate(certificate_out_of_date, { subject, applicationUri: "SomeURI", startDate: lastYear, validity: 300 }, certificateAuthority);
        certificate_not_yet_active = path_1.default.join(testData.tmpFolder, "certificate_notyetactive.pem");
        yield createSignedCertificate(certificate_not_yet_active, { subject, applicationUri: "SomeURI", startDate: nextYear, validity: 10000 }, certificateAuthority);
        certificate_valid = path_1.default.join(testData.tmpFolder, "certificate_valid.pem");
        yield createSignedCertificate(certificate_valid, { subject, applicationUri: "SomeURI", startDate: yesterday, validity: 10 }, certificateAuthority);
        certificate_valid_untrusted = path_1.default.join(testData.tmpFolder, "certificate_valid_untrusted.pem");
        yield createSignedCertificate(certificate_valid_untrusted, { subject, applicationUri: "SomeURI", startDate: yesterday, validity: 10 }, certificateAuthority);
        certificate_valid_signed_with_other_CA = path_1.default.join(testData.tmpFolder, "certificate_valid_from_other_CA.pem");
        yield createSignedCertificate(certificate_valid_signed_with_other_CA, { subject, applicationUri: "SomeURI", startDate: yesterday, validity: 10 }, otherCertificateAuthority);
        yield certificateManager.dispose();
    }));
    describe("should verify ", () => {
        let localCertificateManager;
        let cert1;
        let cert2;
        let cert3;
        let certificate_valid_untrusted_A;
        let caCertificateBuf;
        before(() => __awaiter(this, void 0, void 0, function* () {
            const optionsPKI2 = { location: path_1.default.join(testData.tmpFolder, "TEST_PKI2") };
            localCertificateManager = new lib_1.CertificateManager(optionsPKI2);
            yield localCertificateManager.initialize();
            caCertificateBuf = (0, node_opcua_crypto_1.readCertificate)(certificateAuthority.caCertificate);
            const status = yield localCertificateManager.addIssuer(caCertificateBuf);
            status.should.eql("Good");
            const crl = yield (0, node_opcua_crypto_1.readCertificateRevocationList)(certificateAuthority.revocationList);
            const status1 = yield localCertificateManager.addRevocationList(crl);
            status1.should.eql("Good");
            // get certificate
            cert1 = (0, node_opcua_crypto_1.readCertificate)(certificate_out_of_date);
            yield localCertificateManager.trustCertificate(cert1);
            cert2 = (0, node_opcua_crypto_1.readCertificate)(certificate_not_yet_active);
            yield localCertificateManager.trustCertificate(cert2);
            cert3 = (0, node_opcua_crypto_1.readCertificate)(certificate_valid);
            yield localCertificateManager.trustCertificate(cert3);
            certificate_valid_untrusted_A = (0, node_opcua_crypto_1.readCertificate)(certificate_valid_untrusted);
            yield localCertificateManager.rejectCertificate(certificate_valid_untrusted_A);
        }));
        it("should detect null certificate", () => __awaiter(this, void 0, void 0, function* () {
            const status = yield localCertificateManager.verifyCertificate(null);
            status.toString().should.eql("BadSecurityChecksFailed");
        }));
        it("should detect out of date certificate", () => __awaiter(this, void 0, void 0, function* () {
            const status = yield localCertificateManager.verifyCertificate(cert1);
            status.toString().should.eql("BadCertificateTimeInvalid");
        }));
        it("should detect out of date certificate; but still accept it if option acceptOutdatedCertificate is set", () => __awaiter(this, void 0, void 0, function* () {
            const status = yield localCertificateManager.verifyCertificate(cert1, { acceptOutdatedCertificate: true });
            status.toString().should.eql("Good");
        }));
        it("should detect 'not active yet' certificate", () => __awaiter(this, void 0, void 0, function* () {
            const status = yield localCertificateManager.verifyCertificate(cert2);
            status.toString().should.eql("BadCertificateTimeInvalid");
        }));
        it("should detect  'not active yet'  certificate; but still accept it if option acceptPendingCertificate is set", () => __awaiter(this, void 0, void 0, function* () {
            const status = yield localCertificateManager.verifyCertificate(cert2, { acceptPendingCertificate: true });
            status.toString().should.eql("Good");
        }));
        it("should detect a valid certificate", () => __awaiter(this, void 0, void 0, function* () {
            const status = yield localCertificateManager.verifyCertificate(cert3);
            status.toString().should.eql("Good");
        }));
        it("should detect untrusted certificate", () => __awaiter(this, void 0, void 0, function* () {
            const status = yield localCertificateManager.verifyCertificate(certificate_valid_untrusted_A);
            status.toString().should.eql("BadCertificateUntrusted");
        }));
        it("should find issuer of certificate 1", () => __awaiter(this, void 0, void 0, function* () {
            const issuerCertificate = yield localCertificateManager.findIssuerCertificate(cert1);
            if (!issuerCertificate) {
                throw new Error("Cannot find issuer certificate");
            }
            issuerCertificate.toString("hex").should.eql(caCertificateBuf.toString("hex"));
        }));
    });
});
//# sourceMappingURL=test_certificate_validation.js.map