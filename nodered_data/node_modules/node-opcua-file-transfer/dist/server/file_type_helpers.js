"use strict";
/**
 * @module node-opcua-file-transfer
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defaultMaxSize = exports.FileTypeData = void 0;
exports.writeFile = writeFile;
exports.getFileData = getFileData;
exports.installFileType = installFileType;
const util_1 = require("util");
const fs_1 = __importDefault(require("fs"));
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_address_space_base_1 = require("node-opcua-address-space-base");
const node_opcua_binary_stream_1 = require("node-opcua-binary-stream");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const node_opcua_variant_1 = require("node-opcua-variant");
const node_opcua_data_value_1 = require("node-opcua-data-value");
const open_mode_1 = require("../open_mode");
const debugLog = (0, node_opcua_debug_1.make_debugLog)("FileType");
const errorLog = (0, node_opcua_debug_1.make_errorLog)("FileType");
const warningLog = (0, node_opcua_debug_1.make_warningLog)("FileType");
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)("FileType");
doDebug;
/**
 *
 */
class FileTypeData {
    _fs;
    filename = "";
    maxSize = 0;
    mimeType = "";
    maxChunkSizeBytes = 0;
    file;
    _openCount = 0;
    _fileSize = 0;
    static maxChunkSize = 16 * 1024 * 1024; // 16 MB
    refreshFileContentFunc;
    constructor(options, file) {
        this.file = file;
        this._fs = options.fileSystem || fs_1.default;
        this.refreshFileContentFunc = options.refreshFileContentFunc;
        this.filename = options.filename;
        this.maxSize = options.maxSize;
        this.mimeType = options.mimeType || "";
        this.maxChunkSizeBytes = options.maxChunkSize || FileTypeData.maxChunkSize;
        // openCount indicates the number of currently valid file handles on the file.
        this._openCount = 0;
        file.openCount.bindVariable({
            get: () => new node_opcua_variant_1.Variant({ dataType: node_opcua_variant_1.DataType.UInt16, value: this._openCount })
        }, true);
        file.openCount.minimumSamplingInterval = 0; // changes immediately
        const readFileSize = () => {
            const stat = this._fs.statSync(this.filename);
            const size = stat.size;
            const timestamp = stat.mtime;
            return { size, timestamp };
        };
        const data = this;
        file.size.bindVariable({
            timestamped_get() {
                try {
                    const { size, timestamp } = readFileSize();
                    data.fileSize = size;
                    return new node_opcua_data_value_1.DataValue({
                        sourceTimestamp: timestamp,
                        serverTimestamp: (new Date()),
                        value: new node_opcua_variant_1.Variant({ dataType: node_opcua_variant_1.DataType.UInt64, value: data._fileSize }),
                        statusCode: node_opcua_status_code_1.StatusCodes.Good
                    });
                }
                catch (err) {
                    return new node_opcua_data_value_1.DataValue({
                        serverTimestamp: (new Date()),
                        statusCode: node_opcua_status_code_1.StatusCodes.BadDataUnavailable
                    });
                }
            }
        }, true);
        file.size.minimumSamplingInterval = 0; // changes immediately
        this.refresh();
    }
    set openCount(value) {
        this._openCount = value;
        this.file.openCount.touchValue();
    }
    get openCount() {
        return this._openCount;
    }
    set fileSize(value) {
        this._fileSize = value;
        this.file.size.touchValue();
    }
    get fileSize() {
        return this._fileSize;
    }
    /**
     * refresh position and size
     * this method should be call by the server if the file
     * is modified externally
     *
     */
    async refresh() {
        const abstractFs = this._fs;
        // lauch an async request to update filesize
        await (async function extractFileSize(self) {
            try {
                if (!abstractFs.existsSync(self.filename)) {
                    self._fileSize = 0;
                    return;
                }
                const stat = await (0, util_1.promisify)(abstractFs.stat)(self.filename);
                self._fileSize = stat.size;
                debugLog("original file size ", self.filename, " size = ", self._fileSize);
            }
            catch (err) {
                self._fileSize = 0;
                if (util_1.types.isNativeError(err)) {
                    warningLog("Cannot access file ", self.filename, err.message);
                }
            }
        })(this);
    }
    async refreshFileContent() {
        if (this.refreshFileContentFunc) {
            await this.refreshFileContentFunc();
            await this.refresh();
        }
    }
}
exports.FileTypeData = FileTypeData;
async function writeFile(fileSystem, filename, content) {
    await new Promise((resolve, reject) => {
        fileSystem.open(filename, "w", (err, fd) => {
            // istanbul ignore next
            if (err) {
                return reject(err);
            }
            fileSystem.write(fd, content, 0, content.length, 0, (err) => {
                // istanbul ignore next
                if (err) {
                    return reject(err);
                }
                fileSystem.close(fd, (err) => {
                    // istanbul ignore next
                    if (err) {
                        return reject(err);
                    }
                    resolve();
                });
            });
        });
    });
}
/**
 * @orivate
 */
function getFileData(opcuaFile2) {
    return opcuaFile2.$fileData;
}
function getFileDataFromContext(context) {
    return getFileData(context.object);
}
function _prepare(addressSpace, context) {
    const _context = addressSpace;
    _context.$$currentFileHandle = _context.$$currentFileHandle ? _context.$$currentFileHandle : 41;
    _context.$$files = _context.$$files || {};
    return _context;
}
function _getSessionId(context) {
    if (!context.session) {
        return new node_opcua_nodeid_1.NodeId();
    }
    (0, node_opcua_assert_1.assert)(context.session && context.session.getSessionId);
    return context.session?.getSessionId() || new node_opcua_nodeid_1.NodeId();
}
function _addFile(addressSpace, context, openMode) {
    const _context = _prepare(addressSpace, context);
    _context.$$currentFileHandle++;
    const fileHandle = _context.$$currentFileHandle;
    const sessionId = _getSessionId(context);
    const _fileData = {
        fd: -1,
        handle: fileHandle,
        openMode,
        position: [0, 0],
        size: 0,
        sessionId
    };
    _context.$$files[fileHandle] = _fileData;
    return fileHandle;
}
function _getFileInfo(addressSpace, context, fileHandle) {
    const _context = _prepare(addressSpace, context);
    const _fileInfo = _context.$$files[fileHandle];
    const sessionId = _getSessionId(context);
    if (!_fileInfo || !(0, node_opcua_nodeid_1.sameNodeId)(_fileInfo.sessionId, sessionId)) {
        errorLog("Invalid session ID this file descriptor doesn't belong to this session");
        return null;
    }
    return _fileInfo;
}
function _close(addressSpace, context, fileData) {
    const _context = _prepare(addressSpace, context);
    delete _context.$$files[fileData.fd];
}
function toNodeJSMode(opcuaMode) {
    let flags;
    switch (opcuaMode) {
        case open_mode_1.OpenFileMode.Read:
            flags = "r";
            break;
        case open_mode_1.OpenFileMode.ReadWrite:
        case open_mode_1.OpenFileMode.Write:
            flags = "w+";
            break;
        case open_mode_1.OpenFileMode.ReadWriteAppend:
        case open_mode_1.OpenFileMode.WriteAppend:
            flags = "a+";
            break;
        case open_mode_1.OpenFileMode.WriteEraseExisting:
        case open_mode_1.OpenFileMode.ReadWriteEraseExisting:
            flags = "w+";
            break;
        default:
            flags = "?";
            break;
    }
    return flags;
}
/**
 * Open is used to open a file represented by an Object of FileType.
 * When a client opens a file it gets a file handle that is valid while the
 * session is open. Clients shall use the Close Method to release the handle
 * when they do not need access to the file anymore. Clients can open the
 * same file several times for read.
 * A request to open for writing shall return Bad_NotWritable when the file is
 * already opened.
 * A request to open for reading shall return Bad_NotReadable
 * when the file is already opened for writing.
 *
 * Method Result Codes (defined in Call Service)
 *  Result Code         Description
 *  BadNotReadable      File might be locked and thus not readable.
 *  BadNotWritable      The file is locked and thus not writable.
 *  BadInvalidState
 *  BadInvalidArgument  Mode setting is invalid.
 *  BadNotFound .
 *  BadUnexpectedError
 *
 * @private
 */
async function _openFile(inputArguments, context) {
    const addressSpace = this.addressSpace;
    const mode = inputArguments[0].value;
    /**
     * mode (Byte) Indicates whether the file should be opened only for read operations
     *      or for read and write operations and where the initial position is set.
     *      The mode is an 8-bit unsigned integer used as bit mask with the structure
     *      defined in the following table:
     *      Field        Bit  Description
     *      Read          0   The file is opened for reading. If this bit is not
     *                        set the Read Method cannot be executed.
     *      Write         1   The file is opened for writing. If this bit is not
     *                        set the Write Method cannot be executed.
     *      EraseExisting 2   This bit can only be set if the file is opened for writing
     *                        (Write bit is set). The existing content of the file is
     *                        erased and an empty file is provided.
     *      Append        3   When the Append bit is set the file is opened at end
     *                        of the file, otherwise at begin of the file.
     *                        The SetPosition Method can be used to change the position.
     *      Reserved     4:7  Reserved for future use. Shall always be zero.
     */
    // see https://nodejs.org/api/fs.html#fs_file_system_flags
    const flags = toNodeJSMode(mode);
    if (flags === "?") {
        errorLog("Invalid mode " + open_mode_1.OpenFileMode[mode] + " (" + mode + ")");
        return { statusCode: node_opcua_status_code_1.StatusCodes.BadInvalidArgument };
    }
    /**
     *  fileHandle (UInt32) A handle for the file used in other method calls indicating not the
     *            file (this is done by the Object of the Method call) but the access
     *            request and thus the position in the file. The fileHandle is generated
     *            by the server and is unique for the Session. Clients cannot transfer the
     *            fileHandle to another Session but need to get a new fileHandle by calling
     *            the Open Method.
     */
    const fileHandle = _addFile(addressSpace, context, mode);
    const _fileInfo = _getFileInfo(addressSpace, context, fileHandle);
    if (!_fileInfo) {
        return { statusCode: node_opcua_status_code_1.StatusCodes.BadInvalidArgument };
    }
    const fileData = getFileDataFromContext(context);
    const filename = fileData.filename;
    // make sure file is up to date ... by delegating
    if (mode === open_mode_1.OpenFileMode.Read) {
        await fileData.refreshFileContent();
    }
    const abstractFs = _getFileSystem(context);
    try {
        _fileInfo.fd = await (0, util_1.promisify)(abstractFs.open)(filename, flags);
        // update position
        _fileInfo.position = [0, 0];
        const fileLength = (await (0, util_1.promisify)(abstractFs.stat)(filename)).size;
        _fileInfo.size = fileLength;
        // tslint:disable-next-line:no-bitwise
        if ((mode & open_mode_1.OpenFileModeMask.AppendBit) === open_mode_1.OpenFileModeMask.AppendBit) {
            _fileInfo.position[1] = fileLength;
        }
        if ((mode & open_mode_1.OpenFileModeMask.EraseExistingBit) === open_mode_1.OpenFileModeMask.EraseExistingBit) {
            _fileInfo.size = 0;
        }
        fileData.openCount += 1;
    }
    catch (err) {
        if (util_1.types.isNativeError(err)) {
            errorLog(err.message);
            errorLog(err.stack);
        }
        return { statusCode: node_opcua_status_code_1.StatusCodes.BadUnexpectedError };
    }
    debugLog("Opening file handle ", fileHandle, "filename: ", fileData.filename, "openCount: ", fileData.openCount);
    const callMethodResult = {
        outputArguments: [
            {
                dataType: node_opcua_variant_1.DataType.UInt32,
                value: fileHandle
            }
        ],
        statusCode: node_opcua_status_code_1.StatusCodes.Good
    };
    return callMethodResult;
}
function _getFileSystem(context) {
    const fs = getFileDataFromContext(context)._fs;
    return fs;
}
/**
 * Close is used to close a file represented by a FileType.
 * When a client closes a file the handle becomes invalid.
 *
 * @param inputArguments
 * @param context
 * @private
 */
async function _closeFile(inputArguments, context) {
    const abstractFs = _getFileSystem(context);
    const addressSpace = this.addressSpace;
    const fileHandle = inputArguments[0].value;
    const _fileInfo = _getFileInfo(addressSpace, context, fileHandle);
    if (!_fileInfo) {
        return { statusCode: node_opcua_status_code_1.StatusCodes.BadInvalidArgument };
    }
    const fileData = getFileDataFromContext(context);
    debugLog("Closing file handle ", fileHandle, "filename: ", fileData.filename, "openCount: ", fileData.openCount);
    await (0, util_1.promisify)(abstractFs.close)(_fileInfo.fd);
    _close(addressSpace, context, _fileInfo);
    fileData.openCount -= 1;
    return {
        statusCode: node_opcua_status_code_1.StatusCodes.Good
    };
}
/**
 * Read is used to read a part of the file starting from the current file position.
 * The file position is advanced by the number of bytes read.
 *
 * @param inputArguments
 * @param context
 * @private
 */
async function _readFile(inputArguments, context) {
    const addressSpace = this.addressSpace;
    const abstractFs = _getFileSystem(context);
    //  fileHandle A handle indicating the access request and thus indirectly the
    //  position inside the file.
    const fileHandle = inputArguments[0].value;
    // Length Defines the length in bytes that should be returned in data, starting from the current
    // position of the file handle. If the end of file is reached all data until the end of the file is
    // returned.
    let length = inputArguments[1].value;
    // Only positive values are allowed.
    if (length < 0) {
        return { statusCode: node_opcua_status_code_1.StatusCodes.BadInvalidArgument };
    }
    const _fileInfo = _getFileInfo(addressSpace, context, fileHandle);
    if (!_fileInfo) {
        return { statusCode: node_opcua_status_code_1.StatusCodes.BadInvalidState };
    }
    // tslint:disable-next-line:no-bitwise
    if ((_fileInfo.openMode & open_mode_1.OpenFileModeMask.ReadBit) === 0x0) {
        // open mode did not specify Read Flag
        return { statusCode: node_opcua_status_code_1.StatusCodes.BadInvalidState };
    }
    // Spec says that the the Server is allowed to return less data than specified length.
    //
    // In particular, we have to make sure that the number og bytes returned is not greater than
    // the maxChunkSizeBytes specified in the server configuration.
    // length cannot exceed maxChunkSizeBytes
    const fileData = getFileDataFromContext(context);
    const maxChunkSizeBytes = fileData.maxChunkSizeBytes;
    if (length > maxChunkSizeBytes) {
        length = maxChunkSizeBytes;
    }
    // length cannot either exceed ByteStream.maxChunkSizeBytes
    if (length > node_opcua_binary_stream_1.BinaryStream.maxByteStringLength) {
        length = node_opcua_binary_stream_1.BinaryStream.maxByteStringLength;
    }
    // length cannot either exceed transport OPCUA maxMessageLength - some margin.
    const maxMessageSize = (0, node_opcua_address_space_base_1.getContextMaxMessageSize)(context) - 1024;
    if (maxMessageSize > 0 && length > maxMessageSize) {
        length = maxMessageSize;
    }
    // length cannot either exceed remaining buffer size from current position
    length = Math.min(_fileInfo.size - _fileInfo.position[1], length);
    const data = Buffer.alloc(length);
    let ret = { bytesRead: 0 };
    try {
        // note: we do not util.promise here as it has a wierd behavior...
        ret = await new Promise((resolve, reject) => abstractFs.read(_fileInfo.fd, data, 0, length, _fileInfo.position[1], (err, bytesRead, buff) => {
            if (err) {
                return reject(err);
            }
            return resolve({ bytesRead });
        }));
        _fileInfo.position[1] += ret.bytesRead;
    }
    catch (err) {
        if (util_1.types.isNativeError(err)) {
            errorLog("Read error : ", err.message);
        }
        return { statusCode: node_opcua_status_code_1.StatusCodes.BadUnexpectedError };
    }
    //   Data Contains the returned data of the file. If the ByteString is empty it indicates that the end
    //     of the file is reached.
    return {
        outputArguments: [{ dataType: node_opcua_variant_1.DataType.ByteString, value: data.subarray(0, ret.bytesRead) }],
        statusCode: node_opcua_status_code_1.StatusCodes.Good
    };
}
async function _writeFile(inputArguments, context) {
    const addressSpace = this.addressSpace;
    const abstractFs = _getFileSystem(context);
    const fileHandle = inputArguments[0].value;
    const _fileInfo = _getFileInfo(addressSpace, context, fileHandle);
    if (!_fileInfo) {
        return { statusCode: node_opcua_status_code_1.StatusCodes.BadInvalidArgument };
    }
    // tslint:disable-next-line:no-bitwise
    if ((_fileInfo.openMode & open_mode_1.OpenFileModeMask.WriteBit) === 0x00) {
        // File has not been open with write mode
        return { statusCode: node_opcua_status_code_1.StatusCodes.BadInvalidState };
    }
    const data = inputArguments[1].value;
    let ret = { bytesWritten: 0 };
    try {
        // note: we do not util.promise here as it has a wierd behavior...
        ret = await new Promise((resolve, reject) => {
            abstractFs.write(_fileInfo.fd, data, 0, data.length, _fileInfo.position[1], (err, bytesWritten) => {
                if (err) {
                    errorLog("Err", err);
                    return reject(err);
                }
                return resolve({ bytesWritten });
            });
        });
        (0, node_opcua_assert_1.assert)(typeof ret.bytesWritten === "number");
        _fileInfo.position[1] += ret.bytesWritten;
        _fileInfo.size = Math.max(_fileInfo.size, _fileInfo.position[1]);
        const fileData = getFileDataFromContext(context);
        debugLog(fileData.fileSize);
        fileData.fileSize = Math.max(fileData.fileSize, _fileInfo.position[1]);
        debugLog(fileData.fileSize);
    }
    catch (err) {
        if (util_1.types.isNativeError(err)) {
            errorLog("Write error : ", err.message);
        }
        return { statusCode: node_opcua_status_code_1.StatusCodes.BadUnexpectedError };
    }
    return {
        outputArguments: [],
        statusCode: node_opcua_status_code_1.StatusCodes.Good
    };
}
async function _setPositionFile(inputArguments, context) {
    const addressSpace = this.addressSpace;
    const fileHandle = inputArguments[0].value;
    const position = inputArguments[1].value;
    const _fileInfo = _getFileInfo(addressSpace, context, fileHandle);
    if (!_fileInfo) {
        return { statusCode: node_opcua_status_code_1.StatusCodes.BadInvalidArgument };
    }
    _fileInfo.position = position;
    return { statusCode: node_opcua_status_code_1.StatusCodes.Good };
}
async function _getPositionFile(inputArguments, context) {
    const addressSpace = this.addressSpace;
    const fileHandle = inputArguments[0].value;
    const _fileInfo = _getFileInfo(addressSpace, context, fileHandle);
    if (!_fileInfo) {
        return { statusCode: node_opcua_status_code_1.StatusCodes.BadInvalidArgument };
    }
    return {
        outputArguments: [
            {
                arrayType: node_opcua_variant_1.VariantArrayType.Scalar,
                dataType: node_opcua_variant_1.DataType.UInt64,
                value: _fileInfo.position
            }
        ],
        statusCode: node_opcua_status_code_1.StatusCodes.Good
    };
}
exports.defaultMaxSize = 100000000;
function install_method_handle_on_type(addressSpace) {
    const fileType = addressSpace.findObjectType("FileType");
    if (fileType.open.isBound()) {
        return;
    }
    fileType.open.bindMethod(_openFile);
    fileType.close.bindMethod(_closeFile);
    fileType.read.bindMethod(_readFile);
    fileType.write.bindMethod(_writeFile);
    fileType.setPosition.bindMethod(_setPositionFile);
    fileType.getPosition.bindMethod(_getPositionFile);
}
/**
 * bind all methods of a UAFile OPCUA node
 * @param file the OPCUA Node that has a typeDefinition of FileType
 * @param options the options
 */
function installFileType(_file, options) {
    const file = _file;
    if (file.$fileData) {
        errorLog("File already installed ", file.nodeId.toString(), file.browseName.toString());
        return;
    }
    // make sure that FileType methods are also bound.
    install_method_handle_on_type(file.addressSpace);
    // to protect the server we setup a maximum limit in bytes on the file
    // if the client try to access or set the position above this limit
    // the server will return an error
    options.maxSize = options.maxSize === undefined ? exports.defaultMaxSize : options.maxSize;
    const $fileData = new FileTypeData(options, file);
    file.$fileData = $fileData;
    // ----- install mime type
    if (options.mimeType) {
        if (file.mimeType) {
            file.mimeType.bindVariable({
                get: () => new node_opcua_variant_1.Variant({ dataType: node_opcua_variant_1.DataType.String, value: file.$fileData.mimeType })
            });
        }
    }
    file.open.bindMethod(_openFile);
    file.close.bindMethod(_closeFile);
    file.read.bindMethod(_readFile);
    file.write.bindMethod(_writeFile);
    file.setPosition.bindMethod(_setPositionFile);
    file.getPosition.bindMethod(_getPositionFile);
}
//# sourceMappingURL=file_type_helpers.js.map