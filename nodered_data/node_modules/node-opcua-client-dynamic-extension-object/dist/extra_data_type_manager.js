"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExtraDataTypeManager = void 0;
/**
 * @module node-opcua-client-dynamic-extension-object
 */
const util_1 = require("util");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_factory_1 = require("node-opcua-factory");
class ExtraDataTypeManager {
    namespaceArray = [];
    dataTypeFactoryMapByNamespace = {};
    _session = null;
    _pendingExtractions = new Map();
    constructor() {
        /* */
    }
    setSession(session) {
        this._session = session;
    }
    setNamespaceArray(namespaceArray) {
        this.namespaceArray = namespaceArray;
    }
    hasDataTypeFactory(namespaceIndex) {
        return !!Object.prototype.hasOwnProperty.call(this.dataTypeFactoryMapByNamespace, namespaceIndex);
    }
    registerDataTypeFactory(namespaceIndex, dataTypeFactory) {
        /* istanbul ignore next */
        (0, node_opcua_assert_1.assert)(namespaceIndex !== 0, "registerTypeDictionary cannot be used for namespace 0");
        if (this.hasDataTypeFactory(namespaceIndex)) {
            throw new Error("Dictionary already registered");
        }
        this.dataTypeFactoryMapByNamespace[namespaceIndex] = dataTypeFactory;
    }
    getDataTypeFactoryForNamespace(namespaceIndex) {
        if (namespaceIndex === 0) {
            return (0, node_opcua_factory_1.getStandardDataTypeFactory)();
        }
        return this.dataTypeFactoryMapByNamespace[namespaceIndex];
    }
    getDataTypeFactory(namespaceIndex) {
        if (namespaceIndex === 0) {
            return (0, node_opcua_factory_1.getStandardDataTypeFactory)();
        }
        return this.dataTypeFactoryMapByNamespace[namespaceIndex];
    }
    getBuiltInType(fieldTypeName) {
        // fallback to standard factory
        const standardDataTypeFactory = (0, node_opcua_factory_1.getStandardDataTypeFactory)();
        if (standardDataTypeFactory.hasBuiltInType(fieldTypeName)) {
            return standardDataTypeFactory.getBuiltInType(fieldTypeName);
        }
        throw new Error("Cannot find built-in type " + fieldTypeName);
    }
    getStructureInfoForDataType(dataTypeNodeId) {
        const dataTypeFactory = this.getDataTypeFactory(dataTypeNodeId.namespace);
        if (!dataTypeFactory) {
            throw new Error("cannot find dataFactory for namespace=" + dataTypeNodeId.namespace + " when requested for " + dataTypeNodeId.toString());
        }
        return dataTypeFactory.getStructureInfoForDataType(dataTypeNodeId);
    }
    async getStructureInfoForDataTypeAsync(dataTypeNodeId) {
        const structureInfo = this.getStructureInfoForDataType(dataTypeNodeId);
        if (structureInfo) {
            return structureInfo;
        }
        if (!this._session) {
            throw new Error("Session is required for lazy loading. Call setSession first.");
        }
        const key = dataTypeNodeId.toString();
        if (this._pendingExtractions.has(key)) {
            return await this._pendingExtractions.get(key);
        }
        const promise = (async () => {
            // We'll need to make sure it's accessible and correctly used.
            // For now, let's assume we can import it or move it.
            // Actually, populate_data_type_manager_104.ts exports readDataTypeDefinitionAndBuildType
            const { readDataTypeDefinitionAndBuildType } = require("./private/populate_data_type_manager_104");
            const cache = {}; // local cache for this extraction
            await readDataTypeDefinitionAndBuildType(this._session, dataTypeNodeId, undefined, this, cache);
            const info = this.getStructureInfoForDataType(dataTypeNodeId);
            if (!info) {
                throw new Error("Failed to extract data type structure for " + dataTypeNodeId.toString());
            }
            return info;
        })();
        this._pendingExtractions.set(key, promise);
        try {
            return await promise;
        }
        finally {
            this._pendingExtractions.delete(key);
        }
    }
    getExtensionObjectConstructorFromDataType(dataTypeNodeId) {
        const dataTypeFactory = this.getDataTypeFactory(dataTypeNodeId.namespace);
        if (!dataTypeFactory) {
            throw new Error("cannot find dataFactory for namespace=" + dataTypeNodeId.namespace + " when requested for " + dataTypeNodeId.toString());
        }
        // find schema corresponding to dataTypeNodeId in typeDictionary
        const structureInfo = dataTypeFactory.findStructureInfoForDataType(dataTypeNodeId);
        const Constructor = structureInfo.constructor;
        if (!Constructor) {
            throw new Error("Cannot find Extension Object Constructor for Abstract dataType");
        }
        return Constructor;
    }
    async getExtensionObjectConstructorFromDataTypeAsync(dataTypeNodeId) {
        const structureInfo = await this.getStructureInfoForDataTypeAsync(dataTypeNodeId);
        const Constructor = structureInfo.constructor;
        if (!Constructor) {
            throw new Error("Cannot find Extension Object Constructor for Abstract dataType " + dataTypeNodeId.toString());
        }
        return Constructor;
    }
    getExtensionObjectConstructorFromBinaryEncoding(binaryEncodingNodeId) {
        const dataTypeFactory = this.getDataTypeFactoryForNamespace(binaryEncodingNodeId.namespace);
        const Constructor = dataTypeFactory.getConstructor(binaryEncodingNodeId);
        if (!Constructor) {
            throw new Error("getExtensionObjectConstructorFromBinaryEncoding cannot find constructor for binaryEncoding " +
                binaryEncodingNodeId.toString());
        }
        return Constructor;
    }
    async getExtensionObjectConstructorFromBinaryEncodingAsync(binaryEncodingNodeId) {
        const dataTypeFactory = this.getDataTypeFactoryForNamespace(binaryEncodingNodeId.namespace);
        let Constructor = dataTypeFactory.getConstructor(binaryEncodingNodeId);
        if (Constructor) {
            return Constructor;
        }
        if (!this._session) {
            throw new Error("Session is required for lazy loading. Call setSession first.");
        }
        // Need to find the DataType for this binary encoding
        const browseResult = await this._session.browse({
            nodeId: binaryEncodingNodeId,
            referenceTypeId: "HasEncoding",
            browseDirection: node_opcua_data_model_1.BrowseDirection.Inverse,
            includeSubtypes: false,
            nodeClassMask: node_opcua_data_model_1.NodeClassMask.DataType,
            resultMask: node_opcua_data_model_1.ResultMask.BrowseName
        });
        if (browseResult.statusCode.isNotGood() || !browseResult.references || browseResult.references.length !== 1) {
            throw new Error("Cannot find DataType for binary encoding " + binaryEncodingNodeId.toString());
        }
        const dataTypeNodeId = browseResult.references[0].nodeId;
        await this.getStructureInfoForDataTypeAsync(dataTypeNodeId);
        Constructor = dataTypeFactory.getConstructor(binaryEncodingNodeId);
        if (!Constructor) {
            throw new Error("Cannot find constructor for binary encoding " + binaryEncodingNodeId.toString() + " after extraction");
        }
        return Constructor;
    }
    toString() {
        const l = [];
        function write(...args) {
            l.push(util_1.format.apply(util_1.format, args));
        }
        write("ExtraDataTypeManager");
        for (let n = 0; n < this.namespaceArray.length; n++) {
            write("------------- namespace:", this.namespaceArray[n]);
            const dataFactory = this.dataTypeFactoryMapByNamespace[n];
            if (!dataFactory) {
                continue;
            }
            write(dataFactory.toString());
        }
        return l.join("\n");
    }
}
exports.ExtraDataTypeManager = ExtraDataTypeManager;
//# sourceMappingURL=extra_data_type_manager.js.map