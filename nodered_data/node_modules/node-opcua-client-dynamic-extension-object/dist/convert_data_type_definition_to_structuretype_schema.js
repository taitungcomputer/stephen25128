"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertDataTypeDefinitionToStructureTypeSchema = convertDataTypeDefinitionToStructureTypeSchema;
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_debug_1 = require("node-opcua-debug");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_factory_1 = require("node-opcua-factory");
const node_opcua_nodeid_2 = require("node-opcua-nodeid");
const node_opcua_pseudo_session_1 = require("node-opcua-pseudo-session");
const node_opcua_types_1 = require("node-opcua-types");
const node_opcua_extension_object_1 = require("node-opcua-extension-object");
const node_opcua_schemas_1 = require("node-opcua-schemas");
//
const node_opcua_variant_1 = require("node-opcua-variant");
const node_opcua_constants_1 = require("node-opcua-constants");
const find_encodings_1 = require("./private/find_encodings");
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)(__filename);
const errorLog = (0, node_opcua_debug_1.make_errorLog)(__filename);
const warningLog = (0, node_opcua_debug_1.make_warningLog)(__filename);
async function memoize(cache, cacheName, nodeId, func) {
    const key = nodeId.toString();
    if (cache[cacheName]?.has(key)) {
        cache.hitCount = cache.hitCount === undefined ? 0 : cache.hitCount + 1;
        return cache[cacheName]?.get(key);
    }
    const value = await func();
    if (!cache[cacheName]) {
        cache[cacheName] = new Map();
    }
    cache[cacheName].set(key, value);
    return value;
}
function fromCache(cache, cacheName, nodeId) {
    const key = nodeId.toString();
    if (cache[cacheName]?.has(key)) {
        cache.hitCount = cache.hitCount === undefined ? 0 : cache.hitCount + 1;
        return cache[cacheName]?.get(key);
    }
    return null;
}
async function findSuperType(session, dataTypeNodeId, cache) {
    if (dataTypeNodeId.namespace === 0 && dataTypeNodeId.value === node_opcua_constants_1.DataTypeIds.BaseDataType) {
        // BaseDataType !
        return (0, node_opcua_nodeid_2.coerceNodeId)(0);
    }
    return await memoize(cache, "superType", dataTypeNodeId, async () => {
        const nodeToBrowse3 = {
            browseDirection: node_opcua_data_model_1.BrowseDirection.Inverse,
            includeSubtypes: false,
            nodeClassMask: node_opcua_data_model_1.NodeClassMask.DataType,
            nodeId: dataTypeNodeId,
            referenceTypeId: (0, node_opcua_nodeid_2.resolveNodeId)("HasSubtype"),
            resultMask: (0, node_opcua_data_model_1.makeResultMask)("NodeId | ReferenceType | BrowseName | NodeClass")
        };
        const result3 = await (0, node_opcua_pseudo_session_1.browseAll)(session, nodeToBrowse3);
        /* istanbul ignore next */
        if (result3.statusCode.isNotGood()) {
            throw new Error("Cannot find superType for " + dataTypeNodeId.toString());
        }
        result3.references = result3.references || [];
        /* istanbul ignore next */
        if (result3.references.length !== 1) {
            errorLog("Invalid dataType with more than one (or 0) superType", result3.toString());
            throw new Error("Invalid dataType with more than one (or 0) superType " + dataTypeNodeId.toString() + " l=" + result3.references.length);
        }
        return result3.references[0].nodeId;
    });
}
async function findDataTypeCategory(session, cache, dataTypeNodeId) {
    const subTypeNodeId = await findSuperType(session, dataTypeNodeId, cache);
    doDebug && debugLog("subTypeNodeId  of ", dataTypeNodeId.toString(), " is ", subTypeNodeId.toString());
    const fieldResolution = fromCache(cache, "fieldResolution", subTypeNodeId);
    if (fieldResolution) {
        return fieldResolution.category;
    }
    let category;
    const n = subTypeNodeId;
    if (n.identifierType === node_opcua_nodeid_1.NodeIdType.NUMERIC && n.namespace === 0 && n.value <= 29) {
        // well known node ID !
        switch (n.value) {
            case node_opcua_constants_1.DataTypeIds.Structure:
                category = node_opcua_factory_1.FieldCategory.complex;
                break;
            case node_opcua_constants_1.DataTypeIds.Enumeration:
                category = node_opcua_factory_1.FieldCategory.enumeration;
                break;
            default:
                category = node_opcua_factory_1.FieldCategory.basic;
                break;
        }
        return category;
    }
    // must drill down ...
    return await findDataTypeCategory(session, cache, subTypeNodeId);
}
async function findDataTypeBasicType(session, cache, dataTypeNodeId) {
    const subTypeNodeId = await findSuperType(session, dataTypeNodeId, cache);
    doDebug && debugLog("subTypeNodeId  of ", dataTypeNodeId.toString(), " is ", subTypeNodeId.toString());
    const fieldResolution = fromCache(cache, "fieldResolution", subTypeNodeId);
    if (fieldResolution) {
        return fieldResolution.schema;
    }
    const n = subTypeNodeId;
    if (n.identifierType === node_opcua_nodeid_1.NodeIdType.NUMERIC && n.namespace === 0 && n.value < 29) {
        switch (n.value) {
            case node_opcua_constants_1.DataTypeIds.Structure:
            case node_opcua_constants_1.DataTypeIds.Enumeration:
                throw new Error("Not expecting Structure or Enumeration");
            default:
                break;
        }
        const nameDataValue = await session.read({
            attributeId: node_opcua_data_model_1.AttributeIds.BrowseName,
            nodeId: subTypeNodeId
        });
        const name = nameDataValue.value.value.name;
        return (0, node_opcua_factory_1.getBuiltInType)(name);
    }
    // must drill down ...
    const td = await findDataTypeBasicType(session, cache, subTypeNodeId);
    return td;
}
async function readBrowseNameWithCache(session, nodeId, cache) {
    return await memoize(cache, "browseNameCache", nodeId, async () => {
        const dataValue = await session.read({ nodeId, attributeId: node_opcua_data_model_1.AttributeIds.BrowseName });
        if (dataValue.statusCode.isNotGood()) {
            const message = "cannot extract BrowseName of nodeId = " + nodeId.toString() + " statusCode = " + dataValue.statusCode.toString();
            debugLog(message);
            throw new Error(message);
        }
        return dataValue.value.value.name;
    });
}
async function resolve2(session, dataTypeNodeId, dataTypeManager, fieldTypeName, cache) {
    const dataTypeFactory = dataTypeManager.getDataTypeFactoryForNamespace(dataTypeNodeId.namespace);
    const category = await findDataTypeCategory(session, cache, dataTypeNodeId);
    doDebug && debugLog(" type " + fieldTypeName + " has not been seen yet, let resolve it => (category = ", category, " )");
    let schema = undefined;
    switch (category) {
        case node_opcua_factory_1.FieldCategory.basic:
            schema = await findDataTypeBasicType(session, cache, dataTypeNodeId);
            /* istanbul ignore next */
            if (!schema) {
                errorLog("Cannot find basic type " + fieldTypeName);
            }
            break;
        default:
        case node_opcua_factory_1.FieldCategory.complex:
            {
                const dataTypeDefinitionDataValue = await session.read({
                    attributeId: node_opcua_data_model_1.AttributeIds.DataTypeDefinition,
                    nodeId: dataTypeNodeId
                });
                /* istanbul ignore next */
                if (dataTypeDefinitionDataValue.statusCode.isNotGood()) {
                    throw new Error(" Cannot find dataType Definition ! with nodeId =" + dataTypeNodeId.toString());
                }
                const definition = dataTypeDefinitionDataValue.value.value;
                // OPC UA Spec 1.04 part 6 - 5.2.2.16
                // Enumeration values are represented as a Int32 in the EnumValueType structure.
                // but on 64 bit platform this value could be returned as a [ high, low] tuple.
                // note that this is not correct as per the spec.
                const convertIn64ToInteger = (a) => Array.isArray(a) ? a[1] : a;
                const convert = (fields) => {
                    const retVal = {};
                    fields && fields.forEach((field) => (retVal[field.name || ""] = convertIn64ToInteger(field.value)));
                    return retVal;
                };
                if (category === node_opcua_factory_1.FieldCategory.enumeration) {
                    if (dataTypeFactory.hasEnumeration(fieldTypeName)) {
                        // skipping already known enumeration
                        schema = dataTypeFactory.getEnumeration(fieldTypeName);
                    }
                    else {
                        if (definition instanceof node_opcua_types_1.EnumDefinition) {
                            const e = new node_opcua_factory_1.EnumerationDefinitionSchema(dataTypeNodeId, {
                                enumValues: convert(definition.fields),
                                name: fieldTypeName
                            });
                            dataTypeFactory.registerEnumeration(e);
                            schema = e;
                        }
                    }
                }
                else {
                    const isAbstract = false;
                    schema = await convertDataTypeDefinitionToStructureTypeSchema(session, dataTypeNodeId, fieldTypeName, definition, null, dataTypeManager, isAbstract, cache);
                    const structuredTypeSchema = schema;
                    if (structuredTypeSchema.encodingDefaultBinary && !dataTypeFactory.hasConstructor(structuredTypeSchema.encodingDefaultBinary)) {
                        (0, node_opcua_schemas_1.createDynamicObjectConstructor)(structuredTypeSchema, dataTypeFactory);
                    }
                }
            }
            break;
    }
    return { schema, category };
}
const isExtensionObject = async (session, dataTypeNodeId, cache) => {
    if (dataTypeNodeId.namespace === 0 && dataTypeNodeId.value === node_opcua_variant_1.DataType.ExtensionObject) {
        return true;
    }
    const baseDataType = await findSuperType(session, dataTypeNodeId, cache);
    const bn = baseDataType;
    if (bn.identifierType === node_opcua_nodeid_1.NodeIdType.NUMERIC) {
        if (bn.namespace === 0 && bn.value === node_opcua_variant_1.DataType.ExtensionObject) {
            return true;
        }
        if (bn.namespace === 0 && bn.value < node_opcua_variant_1.DataType.ExtensionObject) {
            return false;
        }
    }
    return await isExtensionObject(session, baseDataType, cache);
};
async function resolveFieldType(session, dataTypeNodeId, dataTypeManager, cache) {
    return await memoize(cache, "fieldResolution", dataTypeNodeId, async () => {
        const dataTypeFactory = dataTypeManager.getDataTypeFactoryForNamespace(dataTypeNodeId.namespace);
        if (dataTypeNodeId.namespace === 0 && dataTypeNodeId.value === node_opcua_constants_1.DataTypeIds.Structure) {
            const category = node_opcua_factory_1.FieldCategory.complex;
            const fieldTypeName = "Structure";
            const schema = node_opcua_extension_object_1.ExtensionObject.schema;
            return {
                category,
                fieldTypeName,
                schema,
                allowSubTypes: true,
                dataType: (0, node_opcua_nodeid_2.coerceNodeId)(node_opcua_variant_1.DataType.ExtensionObject)
            };
        }
        if (dataTypeNodeId.value === 0) {
            const v3 = {
                category: node_opcua_factory_1.FieldCategory.basic,
                fieldTypeName: "Variant",
                schema: dataTypeManager.getBuiltInType("Variant")
            };
            return v3;
        }
        const readIsAbstract = async (dataTypeNodeId) => {
            return (await session.read({ nodeId: dataTypeNodeId, attributeId: node_opcua_data_model_1.AttributeIds.IsAbstract })).value.value;
        };
        const [isAbstract, fieldTypeName, _unusedSuperType] = await Promise.all([
            readIsAbstract(dataTypeNodeId),
            readBrowseNameWithCache(session, dataTypeNodeId, cache),
            findSuperType(session, dataTypeNodeId, cache)
        ]);
        if (isAbstract) {
            const _isExtensionObject = await isExtensionObject(session, dataTypeNodeId, cache);
            doDebug && debugLog(" dataType " + dataTypeNodeId.toString() + " " + fieldTypeName + " is abstract => extObj ?= " + _isExtensionObject);
            if (_isExtensionObject) {
                // we could have complex => Structure
                const v3 = {
                    category: node_opcua_factory_1.FieldCategory.complex,
                    fieldTypeName: fieldTypeName,
                    schema: node_opcua_extension_object_1.ExtensionObject.schema,
                    allowSubTypes: true,
                    dataType: dataTypeNodeId
                };
                return v3;
            }
            else {
                // we could have basic => Variant
                const v3 = {
                    category: node_opcua_factory_1.FieldCategory.basic,
                    fieldTypeName: fieldTypeName,
                    schema: dataTypeManager.getBuiltInType("Variant"),
                    allowSubTypes: true,
                    dataType: dataTypeNodeId
                };
                return v3;
            }
        }
        let schema;
        let category = node_opcua_factory_1.FieldCategory.enumeration;
        if (dataTypeFactory.hasStructureByTypeName(fieldTypeName)) {
            schema = dataTypeFactory.getStructuredTypeSchema(fieldTypeName);
            category = node_opcua_factory_1.FieldCategory.complex;
        }
        else if (dataTypeFactory.hasBuiltInType(fieldTypeName)) {
            category = node_opcua_factory_1.FieldCategory.basic;
            schema = dataTypeFactory.getBuiltInType(fieldTypeName);
        }
        else if (dataTypeFactory.hasEnumeration(fieldTypeName)) {
            category = node_opcua_factory_1.FieldCategory.enumeration;
            schema = dataTypeFactory.getEnumeration(fieldTypeName);
        }
        else {
            doDebug && debugLog(" type " + fieldTypeName + " has not been seen yet, let resolve it");
            const res = await resolve2(session, dataTypeNodeId, dataTypeManager, fieldTypeName, cache);
            schema = res.schema;
            category = res.category;
        }
        /* istanbul ignore next */
        if (!schema) {
            throw new Error("expecting a schema here fieldTypeName=" + fieldTypeName + " " + dataTypeNodeId.toString() + " category = " + category);
        }
        const v2 = {
            category,
            fieldTypeName,
            schema
        };
        return v2;
    });
}
async function _setupEncodings(session, dataTypeNodeId, dataTypeDescription, schema, isAbstract) {
    schema.dataTypeNodeId = dataTypeNodeId;
    if (!isAbstract) {
        const encodings = (dataTypeDescription && dataTypeDescription.encodings) || (await (0, find_encodings_1._findEncodings)(session, dataTypeNodeId));
        schema.encodingDefaultBinary = (0, node_opcua_nodeid_2.makeExpandedNodeId)(encodings.binaryEncodingNodeId);
        schema.encodingDefaultXml = (0, node_opcua_nodeid_2.makeExpandedNodeId)(encodings.xmlEncodingNodeId);
        schema.encodingDefaultJson = (0, node_opcua_nodeid_2.makeExpandedNodeId)(encodings.jsonEncodingNodeId);
    }
    else {
        schema.isAbstract = true;
    }
    return schema;
}
async function findBasicDataTypeEx(session, dataTypeNodeId, cache) {
    return await memoize(cache, "dataTypes", dataTypeNodeId, async () => {
        const sessionEx = session;
        if (!sessionEx._$$cache2) {
            sessionEx._$$cache2 = new Map();
        }
        const key = dataTypeNodeId.toString();
        if (sessionEx._$$cache2.has(key)) {
            sessionEx._$$cacheHits = sessionEx._$$cacheHits == undefined ? 0 : sessionEx._$$cacheHits + 1;
            // debugLog("cache hit 2", key);
            return sessionEx._$$cache2.get(key);
        }
        const d = await (0, node_opcua_pseudo_session_1.findBasicDataType)(session, dataTypeNodeId);
        sessionEx._$$cache2.set(key, d);
        return d;
    });
}
async function nonReentrant(cache, prefix, dataTypeNodeId, func) {
    const key = prefix + dataTypeNodeId.toString();
    if (cache.$$resolveStuff?.has(key)) {
        doDebug && debugLog(" re-entering !" + key);
        return await new Promise((resolve, reject) => {
            cache.$$resolveStuff?.get(key).push([resolve, reject]);
        });
    }
    cache.$$resolveStuff = cache.$$resolveStuff || new Map();
    cache.$$resolveStuff.set(key, []);
    return await new Promise((_resolve, _reject) => {
        cache.$$resolveStuff.get(key).push([_resolve, _reject]);
        (async () => {
            try {
                const result = await func();
                const tmp = cache.$$resolveStuff.get(key);
                cache.$$resolveStuff.delete(key);
                for (const [resolve] of tmp) {
                    resolve(result);
                }
            }
            catch (err) {
                const tmp = cache.$$resolveStuff.get(key);
                cache.$$resolveStuff.delete(key);
                for (const [_resolve, reject] of tmp) {
                    reject(err);
                }
            }
        })();
    });
}
// eslint-disable-next-line max-statements, max-params
async function convertDataTypeDefinitionToStructureTypeSchema(session, dataTypeNodeId, name, definition, dataTypeDescription, dataTypeManager, isAbstract, cache) {
    return await nonReentrant(cache, "convertDataTypeDefinitionToStructureTypeSchema", dataTypeNodeId, async () => {
        if (definition instanceof node_opcua_types_1.StructureDefinition) {
            const dataTypeFactory = dataTypeManager.getDataTypeFactoryForNamespace(dataTypeNodeId.namespace);
            let fieldCountToIgnore = 0;
            const structureInfo = dataTypeManager.getStructureInfoForDataType(definition.baseDataType);
            const baseSchema = structureInfo?.schema;
            if (baseSchema) {
                const possibleFields = (0, node_opcua_factory_1.extractAllPossibleFields)(baseSchema);
                fieldCountToIgnore += possibleFields.length;
            }
            const fields = [];
            const isUnion = definition.structureType === node_opcua_types_1.StructureType.Union;
            switch (definition.structureType) {
                case node_opcua_types_1.StructureType.Union:
                    fields.push({
                        fieldType: "UInt32",
                        name: "SwitchField"
                    });
                    break;
                case node_opcua_types_1.StructureType.Structure:
                case node_opcua_types_1.StructureType.StructureWithOptionalFields:
                // new in 1.05
                case node_opcua_types_1.StructureType.StructureWithSubtypedValues:
                case node_opcua_types_1.StructureType.UnionWithSubtypedValues:
                    break;
            }
            let switchValue = 1;
            let switchBit = 0;
            const bitFields = isUnion ? undefined : [];
            const postActions = [];
            if (definition.fields) {
                // pre-fetch all dataTypes in parallel
                const dataTypesToResolve = [];
                const seen = new Set();
                if (!(0, node_opcua_nodeid_1.sameNodeId)(definition.baseDataType, dataTypeNodeId)) {
                    dataTypesToResolve.push(definition.baseDataType);
                    seen.add(definition.baseDataType.toString());
                }
                for (let i = fieldCountToIgnore; i < definition.fields.length; i++) {
                    const fieldD = definition.fields[i];
                    const key = fieldD.dataType.toString();
                    if (seen.has(key))
                        continue;
                    seen.add(key);
                    if ((0, node_opcua_nodeid_1.sameNodeId)(fieldD.dataType, dataTypeNodeId))
                        continue;
                    dataTypesToResolve.push(fieldD.dataType);
                }
                await Promise.all([
                    ...dataTypesToResolve.map((dataType) => resolveFieldType(session, dataType, dataTypeManager, cache)),
                    ...dataTypesToResolve.map((dataType) => findBasicDataTypeEx(session, dataType, cache)),
                    !isAbstract ? (0, find_encodings_1._findEncodings)(session, dataTypeNodeId) : Promise.resolve(null)
                ]);
                const results = await Promise.all(definition.fields.slice(fieldCountToIgnore).map(async (fieldD) => {
                    const isSelf = (0, node_opcua_nodeid_1.sameNodeId)(fieldD.dataType, dataTypeNodeId);
                    // Pre-fetch async data for each field in parallel
                    const rt = isSelf ? null : await resolveFieldType(session, fieldD.dataType, dataTypeManager, cache);
                    const basicDataType = rt ? await findBasicDataTypeEx(session, rt.dataType || fieldD.dataType, cache) : (isSelf ? node_opcua_variant_1.DataType.ExtensionObject : undefined);
                    const fieldTypeNameForSelfRef = (isSelf)
                        ? await readBrowseNameWithCache(session, dataTypeNodeId, cache)
                        : undefined;
                    return { fieldD, rt, basicDataType, fieldTypeNameForSelfRef };
                }));
                for (const { fieldD, rt, basicDataType, fieldTypeNameForSelfRef } of results) {
                    let field;
                    let currentAllowSubTypes;
                    ({ field, switchBit, switchValue, allowSubTypes: currentAllowSubTypes } = createField(definition, fieldD, switchBit, bitFields, isUnion, switchValue));
                    if (fieldD.dataType.value === dataTypeNodeId.value && fieldD.dataType.namespace === dataTypeNodeId.namespace) {
                        // this is a structure with a field of the same type
                        // push an empty placeholder that we will fill later
                        (field.fieldType = fieldTypeNameForSelfRef), (field.category = node_opcua_factory_1.FieldCategory.complex);
                        fields.push(field);
                        const capturedField = field;
                        postActions.push((schema) => {
                            capturedField.schema = schema;
                        });
                        continue;
                    }
                    const resolvedField = rt;
                    const { schema, category, fieldTypeName, dataType } = resolvedField;
                    field.fieldType = fieldTypeName;
                    field.category = category;
                    field.schema = schema;
                    field.dataType = dataType || fieldD.dataType;
                    field.allowSubTypes = currentAllowSubTypes;
                    field.basicDataType = basicDataType;
                    fields.push(field);
                }
            }
            /// some server may provide definition.baseDataType to be i=22 (ExtensionObject)
            /// instead of 12756 Union;
            if (isUnion && (0, node_opcua_nodeid_1.sameNodeId)(definition.baseDataType, (0, node_opcua_nodeid_2.coerceNodeId)(node_opcua_constants_1.DataTypeIds.Structure))) {
                definition.baseDataType = (0, node_opcua_nodeid_2.resolveNodeId)(node_opcua_constants_1.DataTypeIds.Union); // aka DataTypeIds.Union
            }
            const a = await resolveFieldType(session, definition.baseDataType, dataTypeManager, cache);
            const baseType = a ? a.fieldTypeName : isUnion ? "Union" : "ExtensionObject";
            const os = new node_opcua_factory_1.StructuredTypeSchema({
                baseType,
                bitFields,
                fields,
                name,
                dataTypeFactory
            });
            const structuredTypeSchema = await _setupEncodings(session, dataTypeNodeId, dataTypeDescription, os, isAbstract);
            postActions.forEach((action) => action(structuredTypeSchema));
            doDebug && debugLog("DONE ! convertDataTypeDefinitionToStructureTypeSchema = ", dataTypeNodeId.toString());
            return structuredTypeSchema;
        }
        throw new Error("Not Implemented");
    });
    function createField(definition, fieldD, switchBit, bitFields, isUnion, switchValue) {
        const field = {
            fieldType: "",
            name: fieldD.name,
            schema: undefined
        };
        const definitionAllowSubTypes = definition.structureType === node_opcua_types_1.StructureType.StructureWithSubtypedValues
            || definition.structureType === node_opcua_types_1.StructureType.UnionWithSubtypedValues;
        if (fieldD.isOptional) {
            // Optional has a special handling
            if (!definitionAllowSubTypes) {
                // we are in a true optional field structure
                field.switchBit = switchBit++;
                bitFields?.push({ name: fieldD.name + "Specified", length: 1 });
            }
        }
        if (isUnion) {
            field.switchValue = switchValue;
            switchValue += 1;
        }
        const allowSubTypes = definitionAllowSubTypes && fieldD.isOptional;
        // (fieldD.valueRank === -1 || fieldD.valueRank === 1 || fieldD.valueRank === 0);
        if (fieldD.valueRank >= 1) {
            field.valueRank = fieldD.valueRank;
            field.isArray = true;
        }
        else {
            field.isArray = false;
        }
        return { field, switchBit, switchValue, allowSubTypes };
    }
}
//# sourceMappingURL=convert_data_type_definition_to_structuretype_schema.js.map