"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataTypeExtractStrategy = void 0;
exports.serverImplementsDataTypeDefinition = serverImplementsDataTypeDefinition;
exports.populateDataTypeManager = populateDataTypeManager;
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_pseudo_session_1 = require("node-opcua-pseudo-session");
const node_opcua_constants_1 = require("node-opcua-constants");
const node_opcua_service_translate_browse_path_1 = require("node-opcua-service-translate-browse-path");
const populate_data_type_manager_103_1 = require("./private/populate_data_type_manager_103");
const populate_data_type_manager_104_1 = require("./private/populate_data_type_manager_104");
const node_opcua_factory_1 = require("node-opcua-factory");
const node_opcua_debug_1 = require("node-opcua-debug");
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)("populateDataTypeManager");
const debugLog = (0, node_opcua_debug_1.make_debugLog)("populateDataTypeManager");
const ComplexTypes2017 = "http://opcfoundation.org/UA-Profile/Server/ComplexTypes2017";
async function serverImplementsDataTypeDefinition(session) {
    const dataValueServerCapabilities = await session.read({
        nodeId: (0, node_opcua_nodeid_1.resolveNodeId)(node_opcua_constants_1.VariableIds.Server_ServerCapabilities_ServerProfileArray),
        attributeId: node_opcua_data_model_1.AttributeIds.Value
    });
    const serverCapabilities = dataValueServerCapabilities.value?.value ?? [];
    if (serverCapabilities.indexOf(ComplexTypes2017) >= 0) {
        doDebug && debugLog("server implements ComplexTypes2017");
        return true;
    }
    // Check if any non-deprecated 1.03 dictionary exists
    const browseResult1 = await session.browse({
        browseDirection: node_opcua_data_model_1.BrowseDirection.Forward,
        includeSubtypes: true,
        nodeClassMask: node_opcua_data_model_1.NodeClassMask.Variable,
        nodeId: (0, node_opcua_nodeid_1.resolveNodeId)(node_opcua_constants_1.ObjectIds.OPCBinarySchema_TypeSystem),
        resultMask: node_opcua_data_model_1.ResultMask.TypeDefinition
    });
    const references103 = browseResult1.references || [];
    for (const ref of references103) {
        const td = ref.typeDefinition;
        if (td.namespace === 0 && td.value === node_opcua_constants_1.VariableTypeIds.DataTypeDictionaryType) {
            const p = await session.translateBrowsePath((0, node_opcua_service_translate_browse_path_1.makeBrowsePath)(ref.nodeId, "/Deprecated"));
            if (!p.statusCode.isGood() || !p.targets || p.targets.length === 0) {
                doDebug && debugLog("server implements 1.03 dictionary but no Deprecated node found");
                return false;
            }
            const deprecatedNodeId = p.targets[0].targetId;
            const dataValue = await session.read({ nodeId: deprecatedNodeId, attributeId: node_opcua_data_model_1.AttributeIds.Value });
            if (dataValue.statusCode.isGood() && dataValue.value.value === false) {
                doDebug && debugLog("server implements 1.03 dictionary but Deprecated node is true");
                return false;
            }
        }
    }
    // Try to find AT LEAST ONE custom DataType and check its DataTypeDefinition
    // We browse the Structure type (22) without recursion first
    const browseResult2 = await session.browse({
        browseDirection: node_opcua_data_model_1.BrowseDirection.Forward,
        includeSubtypes: true,
        nodeClassMask: node_opcua_data_model_1.NodeClassMask.DataType,
        nodeId: (0, node_opcua_nodeid_1.resolveNodeId)(node_opcua_constants_1.DataTypeIds.Structure),
        referenceTypeId: (0, node_opcua_nodeid_1.resolveNodeId)("HasSubtype"),
        resultMask: 63
    });
    const references = browseResult2.references || [];
    const customDataType = references.find(r => r.nodeId.namespace !== 0);
    if (customDataType) {
        const dv = await session.read({ nodeId: customDataType.nodeId, attributeId: node_opcua_data_model_1.AttributeIds.DataTypeDefinition });
        if (dv.statusCode.isGood()) {
            doDebug && debugLog("server implements 1.04 dictionary with custom DataType");
            return true;
        }
    }
    else {
        const standardDataType = references.find(r => r.nodeId.namespace == 0);
        if (standardDataType) {
            const dv = await session.read({ nodeId: standardDataType.nodeId, attributeId: node_opcua_data_model_1.AttributeIds.DataTypeDefinition });
            if (dv.statusCode.isGood()) {
                doDebug && debugLog("server implements 1.04 dictionary with standard DataType");
                return true;
            }
        }
    }
    // If no custom type at first level, check Union too
    const browseResult3 = await session.browse({
        browseDirection: node_opcua_data_model_1.BrowseDirection.Forward,
        includeSubtypes: true,
        nodeClassMask: node_opcua_data_model_1.NodeClassMask.DataType,
        nodeId: (0, node_opcua_nodeid_1.resolveNodeId)(node_opcua_constants_1.DataTypeIds.Union),
        referenceTypeId: (0, node_opcua_nodeid_1.resolveNodeId)("HasSubtype"),
        resultMask: 63
    });
    const customDataType2 = (browseResult3.references || []).find(r => r.nodeId.namespace !== 0);
    if (customDataType2) {
        const dv = await session.read({ nodeId: customDataType2.nodeId, attributeId: node_opcua_data_model_1.AttributeIds.DataTypeDefinition });
        if (dv.statusCode.isGood()) {
            doDebug && debugLog("server implements 1.04 dictionary with custom Union");
            return true;
        }
    }
    doDebug && debugLog("server does not implement 1.04 dictionary or we cannot find any evidence of it");
    return false;
}
var DataTypeExtractStrategy;
(function (DataTypeExtractStrategy) {
    DataTypeExtractStrategy[DataTypeExtractStrategy["Auto"] = 0] = "Auto";
    DataTypeExtractStrategy[DataTypeExtractStrategy["Force103"] = 1] = "Force103";
    DataTypeExtractStrategy[DataTypeExtractStrategy["Force104"] = 2] = "Force104";
    DataTypeExtractStrategy[DataTypeExtractStrategy["Both"] = 3] = "Both";
    DataTypeExtractStrategy[DataTypeExtractStrategy["Lazy"] = 4] = "Lazy";
})(DataTypeExtractStrategy || (exports.DataTypeExtractStrategy = DataTypeExtractStrategy = {}));
;
async function populateDataTypeManager(session, dataTypeManager, strategy) {
    dataTypeManager.setSession(session);
    if (strategy === DataTypeExtractStrategy.Lazy) {
        doDebug && debugLog("populateDataTypeManager: Lazy mode");
        const force104 = await serverImplementsDataTypeDefinition(session);
        if (force104) {
            doDebug && debugLog("populateDataTypeManager: Lazy mode - server implements 1.04 dictionary - we will be lazy");
            // we are in lazy mode for 1.0.5+
            // create teh dataTypeFactory for namespace 1
            const namespace = await (0, node_opcua_pseudo_session_1.readNamespaceArray)(session);
            for (let i = 1; i < namespace.length; i++) {
                let dataTypeFactory = dataTypeManager.getDataTypeFactory(i);
                if (!dataTypeFactory) {
                    dataTypeFactory = new node_opcua_factory_1.DataTypeFactory([]);
                    dataTypeManager.registerDataTypeFactory(i, dataTypeFactory);
                    //   throw new Error("cannot find dataType Manager for namespace of " + dataTypeNodeId.toString());
                }
            }
            return;
        }
        doDebug && debugLog("populateDataTypeManager: Lazy mode - server does not implement 1.04 dictionary - we will be eager");
        // for old 1.03 servers we must be eager as we don't have a way to lazy load 1.03 dictionaries yet
        await (0, populate_data_type_manager_103_1.populateDataTypeManager103)(session, dataTypeManager);
        await (0, populate_data_type_manager_104_1.populateDataTypeManager104)(session, dataTypeManager);
        return;
    }
    if (strategy === DataTypeExtractStrategy.Auto) {
        doDebug && debugLog("populateDataTypeManager: Auto mode");
        const force104 = await serverImplementsDataTypeDefinition(session);
        if (force104) {
            doDebug && debugLog("populateDataTypeManager: Auto mode - server implements 1.04 dictionary - we will be 104 eager");
            await (0, populate_data_type_manager_104_1.populateDataTypeManager104)(session, dataTypeManager);
            return;
        }
        doDebug && debugLog("populateDataTypeManager: Auto mode - server does not implement 1.04 dictionary - we will be 103 eager and 104 eager");
        // old way for 1.03 and early 1.04 prototype
        await (0, populate_data_type_manager_103_1.populateDataTypeManager103)(session, dataTypeManager);
        await (0, populate_data_type_manager_104_1.populateDataTypeManager104)(session, dataTypeManager);
        return;
    }
    if (strategy == DataTypeExtractStrategy.Force103 || strategy == DataTypeExtractStrategy.Both) {
        doDebug && debugLog("populateDataTypeManager: Force103 mode - we will be 103 eager");
        await (0, populate_data_type_manager_103_1.populateDataTypeManager103)(session, dataTypeManager);
    }
    if (strategy == DataTypeExtractStrategy.Force104 || strategy == DataTypeExtractStrategy.Both) {
        doDebug && debugLog("populateDataTypeManager: Force104 mode - we will be 104 eager");
        await (0, populate_data_type_manager_104_1.populateDataTypeManager104)(session, dataTypeManager);
    }
}
//# sourceMappingURL=populate_data_type_manager.js.map